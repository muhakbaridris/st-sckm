<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisasi SCKM & ST-SCKM - Interaktif</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary: #1a2980;
            --secondary: #26d0ce;
            --accent1: #FF6B6B;
            --accent2: #4ECDC4;
            --accent3: #FFD166;
            --light: #f5f7fa;
            --dark: #2d3748;
            --gray: #718096;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            color: var(--dark);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Header */
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 30px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            animation: fadeInDown 0.8s ease-out;
        }
        
        header::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.3;
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
        }
        
        .subtitle {
            font-size: 1.4rem;
            opacity: 0.9;
            max-width: 900px;
            margin: 0 auto 20px;
            position: relative;
            z-index: 1;
        }
        
        .header-badges {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
            position: relative;
            z-index: 1;
        }
        
        .badge {
            background-color: rgba(255, 255, 255, 0.2);
            padding: 8px 20px;
            border-radius: 50px;
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Tab Container */
        .tab-container {
            display: flex;
            margin-bottom: 30px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            animation: fadeInUp 0.8s ease-out 0.2s both;
        }
        
        .tabs {
            display: flex;
            flex-wrap: wrap;
            width: 100%;
        }
        
        .tab {
            flex: 1;
            padding: 20px 25px;
            background: none;
            border: none;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--gray);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            position: relative;
            min-width: 200px;
        }
        
        .tab:hover {
            background-color: rgba(26, 41, 128, 0.05);
            color: var(--primary);
        }
        
        .tab.active {
            background-color: var(--primary);
            color: white;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 10px solid white;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
            padding: 40px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            margin-bottom: 40px;
            animation: fadeIn 0.5s ease-out;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Section Titles */
        .section-title {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            color: var(--primary);
            font-size: 1.8rem;
        }
        
        .section-title i {
            font-size: 2rem;
            color: var(--secondary);
        }
        
        /* Visualization Container */
        .visualization-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(550px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1200px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }
        
        /* Canvas Card */
        .canvas-card {
            background-color: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: transform 0.3s, box-shadow 0.3s;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .canvas-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--light);
        }
        
        .card-title {
            font-size: 1.5rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-title i {
            font-size: 1.5rem;
        }
        
        .card-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        /* Canvas */
        .canvas-container {
            position: relative;
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            background-color: #f9fafc;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }
        
        canvas {
            display: block;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.03);
            max-width: 100%;
            height: auto;
        }
        
        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: rgba(0, 0, 0, 0.02);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        /* Buttons */
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), #2a3a9e);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #15246d, var(--primary));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(26, 41, 128, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, var(--secondary), #2ce2e0);
            color: white;
        }
        
        .btn-secondary:hover {
            background: linear-gradient(135deg, #20b8b6, var(--secondary));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(38, 208, 206, 0.3);
        }
        
        .btn-accent {
            background: linear-gradient(135deg, var(--accent1), #ff8585);
            color: white;
        }
        
        .btn-accent:hover {
            background: linear-gradient(135deg, #ff5252, var(--accent1));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        
        .btn-outline {
            background-color: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
        }
        
        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Step Controls */
        .step-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 30px;
        }
        
        .step-info {
            background-color: rgba(26, 41, 128, 0.05);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid var(--primary);
        }
        
        .step-title {
            font-size: 1.3rem;
            color: var(--primary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .step-description {
            color: var(--gray);
            line-height: 1.7;
        }
        
        .step-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        
        .step-buttons {
            display: flex;
            gap: 10px;
        }
        
        .step-counter {
            font-weight: 600;
            color: var(--primary);
            background-color: rgba(26, 41, 128, 0.1);
            padding: 8px 16px;
            border-radius: 50px;
        }
        
        /* Formula Container */
        .formula-container {
            background: linear-gradient(135deg, #f0f7ff, #e6f3ff);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border-left: 5px solid var(--primary);
            position: relative;
            overflow: hidden;
        }
        
        .formula-container::before {
            content: "∑";
            position: absolute;
            top: -20px;
            right: 10px;
            font-size: 6rem;
            opacity: 0.05;
            color: var(--primary);
            font-weight: bold;
        }
        
        .formula-title {
            font-size: 1.4rem;
            color: var(--primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .formula {
            font-family: 'Courier New', monospace;
            font-size: 1.3rem;
            color: var(--dark);
            text-align: center;
            margin: 15px 0;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .formula-variables {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 12px;
            margin-top: 20px;
        }
        
        .variable {
            padding: 12px 15px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            font-size: 0.95rem;
            border-left: 4px solid var(--secondary);
        }
        
        /* Comparison */
        .comparison-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }
        
        .comparison-card {
            padding: 30px;
            border-radius: 15px;
            background-color: white;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s;
        }
        
        .comparison-card:hover {
            transform: translateY(-5px);
        }
        
        .comparison-title {
            font-size: 1.5rem;
            color: var(--primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--light);
        }
        
        .comparison-list {
            list-style-type: none;
        }
        
        .comparison-list li {
            padding: 12px 0;
            border-bottom: 1px dashed #e2e8f0;
            display: flex;
            align-items: flex-start;
        }
        
        .comparison-list li:before {
            content: "✓";
            color: var(--secondary);
            font-weight: bold;
            margin-right: 12px;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        
        /* Algorithm Steps */
        .algorithm-steps-container {
            margin-top: 40px;
        }
        
        .algorithm-step {
            display: flex;
            align-items: flex-start;
            margin-bottom: 20px;
            padding: 25px;
            border-radius: 12px;
            background-color: rgba(0, 0, 0, 0.02);
            transition: transform 0.3s, background-color 0.3s;
            border-left: 5px solid transparent;
        }
        
        .algorithm-step:hover {
            transform: translateX(5px);
            background-color: rgba(26, 41, 128, 0.05);
        }
        
        .algorithm-step.active {
            border-left-color: var(--primary);
            background-color: rgba(26, 41, 128, 0.08);
        }
        
        .step-number {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            margin-right: 20px;
            flex-shrink: 0;
            box-shadow: 0 5px 15px rgba(26, 41, 128, 0.2);
        }
        
        .step-content {
            flex-grow: 1;
        }
        
        .step-content h4 {
            margin-bottom: 10px;
            color: var(--primary);
            font-size: 1.3rem;
        }
        
        /* Footer */
        footer {
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            color: var(--gray);
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeInDown {
            from { 
                opacity: 0;
                transform: translateY(-30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeInUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Save Notification */
        .save-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            animation: fadeInUp 0.3s ease-out, fadeOut 0.3s ease-out 2.7s forwards;
        }
        
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(20px); }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            
            .subtitle {
                font-size: 1.1rem;
            }
            
            .tab {
                min-width: 150px;
                padding: 15px;
                font-size: 1rem;
            }
            
            .visualization-container {
                grid-template-columns: 1fr;
            }
            
            .card-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            
            .card-actions {
                width: 100%;
                justify-content: center;
            }
            
            .step-navigation {
                flex-direction: column;
            }
            
            .formula {
                font-size: 1rem;
                padding: 15px;
            }
            
            .comparison-container {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            header {
                padding: 30px 20px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .tab {
                min-width: 120px;
                padding: 12px;
                font-size: 0.9rem;
            }
            
            .tab-content {
                padding: 25px 20px;
            }
            
            .btn {
                padding: 10px 18px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-project-diagram"></i> Visualisasi SCKM & ST-SCKM</h1>
            <p class="subtitle">Spatially Constrained K-Means dan Spatio-Temporal SCKM: Algoritma klastering dengan batasan ruang dan waktu</p>
            
            <div class="header-badges">
                <div class="badge">
                    <i class="fas fa-save"></i> Save Gambar
                </div>
                <div class="badge">
                    <i class="fas fa-play-circle"></i> Step-by-Step
                </div>
                <div class="badge">
                    <i class="fas fa-chart-line"></i> Visualisasi Interaktif
                </div>
            </div>
        </header>
        
        <div class="tab-container">
            <div class="tabs">
                <button class="tab active" data-tab="sckm">
                    <i class="fas fa-map-marked-alt"></i> SCKM
                </button>
                <button class="tab" data-tab="st-sckm">
                    <i class="fas fa-clock"></i> ST-SCKM
                </button>
                <button class="tab" data-tab="comparison">
                    <i class="fas fa-balance-scale"></i> Perbandingan
                </button>
            </div>
        </div>
        
        <!-- Tab 1: SCKM -->
        <div id="sckm" class="tab-content active">
            <div class="section-title">
                <i class="fas fa-map-marked-alt"></i>
                <h2>SCKM (Spatially Constrained K-Means)</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">SCKM adalah pengembangan dari algoritma K-Means tradisional yang menambahkan batasan spasial. Dalam konteks ini, setiap titik data hanya dapat tergabung dalam klaster yang memiliki centroid dalam jarak tertentu (batasan spasial).</p>
            
            <div class="formula-container">
                <h3 class="formula-title"><i class="fas fa-calculator"></i> Rumus SCKM Objective Function</h3>
                <div class="formula">J = Σ<sub>i=1</sub><sup>n</sup> Σ<sub>j=1</sub><sup>k</sup> w<sub>ij</sub> ||x<sub>i</sub> - c<sub>j</sub>||² + λ Σ<sub>i=1</sub><sup>n</sup> Σ<sub>j=1</sub><sup>k</sup> φ<sub>ij</sub></div>
                <div class="formula-variables">
                    <div class="variable">
                        <strong>w<sub>ij</sub></strong>: Indikator keanggotaan titik i ke klaster j (1 jika ya, 0 jika tidak)
                    </div>
                    <div class="variable">
                        <strong>x<sub>i</sub></strong>: Vektor fitur titik data ke-i
                    </div>
                    <div class="variable">
                        <strong>c<sub>j</sub></strong>: Centroid klaster ke-j
                    </div>
                    <div class="variable">
                        <strong>λ</strong>: Parameter penyeimbang antara kesesuaian data dan batasan spasial
                    </div>
                    <div class="variable">
                        <strong>φ<sub>ij</sub></strong>: Fungsi batasan spasial (biasanya berbasis jarak)
                    </div>
                </div>
            </div>
            
            <div class="visualization-container">
                <!-- Visualisasi SCKM -->
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-dot-circle"></i> Visualisasi SCKM</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-sckm">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-sckm">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="sckm-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Core Points</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Border Points</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Noise Points</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #1A2980;"></div>
                            <span>Centroid</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" id="prev-sckm">
                            <i class="fas fa-chevron-left"></i> Sebelumnya
                        </button>
                        <button class="btn btn-accent" id="next-sckm">
                            <i class="fas fa-chevron-right"></i> Berikutnya
                        </button>
                        <button class="btn btn-primary" id="run-sckm">
                            <i class="fas fa-play"></i> Jalankan Semua
                        </button>
                    </div>
                </div>
                
                <!-- Konsep MinPts -->
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-bullseye"></i> Konsep MinPts dan Jarak</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-minpts">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-minpts">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="minpts-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Core Point (MinPts ≥ 5)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Border Point (terhubung ke core)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Noise Point (tidak terhubung)</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-outline" id="add-point">
                            <i class="fas fa-plus-circle"></i> Tambah Titik
                        </button>
                        <button class="btn btn-secondary" id="show-radius">
                            <i class="fas fa-circle"></i> Tampilkan Radius
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Step-by-Step untuk SCKM -->
            <div class="step-controls">
                <div class="step-info">
                    <h4 class="step-title" id="sckm-step-title">Langkah 1: Inisialisasi</h4>
                    <p class="step-description" id="sckm-step-description">Tentukan jumlah klaster (k) dan parameter spasial (jarak maksimum antara titik dan centroid). Posisikan centroid secara acak atau dengan metode tertentu.</p>
                </div>
                
                <div class="step-navigation">
                    <div class="step-counter">
                        Langkah: <span id="sckm-current-step">1</span> dari <span id="sckm-total-steps">5</span>
                    </div>
                    <div class="step-buttons">
                        <button class="btn btn-outline" id="prev-step-sckm">
                            <i class="fas fa-chevron-left"></i> Langkah Sebelumnya
                        </button>
                        <button class="btn btn-primary" id="next-step-sckm">
                            Langkah Berikutnya <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Langkah-langkah Algoritma SCKM -->
            <div class="algorithm-steps-container">
                <h3 class="section-title" style="margin-top: 50px;">
                    <i class="fas fa-list-ol"></i>
                    <span>Langkah-langkah Algoritma SCKM</span>
                </h3>
                
                <div class="algorithm-step active" id="step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Inisialisasi</h4>
                        <p>Tentukan jumlah klaster (k) dan parameter spasial (jarak maksimum antara titik dan centroid). Posisikan centroid secara acak atau dengan metode tertentu.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Penempatan Awal Centroid</h4>
                        <p>Pilih posisi awal centroid. Ini dapat dilakukan secara acak atau dengan metode seperti K-Means++ untuk hasil yang lebih baik.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Penugasan Titik dengan Batasan Spasial</h4>
                        <p>Setiap titik ditugaskan ke centroid terdekat yang masih dalam batasan jarak spasial. Titik yang berada di luar batasan semua centroid ditandai sebagai noise.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Perbarui Centroid</h4>
                        <p>Hitung ulang posisi centroid berdasarkan titik-titik yang ditugaskan ke klaster tersebut. Centroid baru adalah rata-rata dari semua titik dalam klaster.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="step-5">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h4>Iterasi hingga Konvergen</h4>
                        <p>Ulangi langkah 3 dan 4 sampai konvergen (centroid tidak berubah atau perubahan sangat kecil) atau mencapai jumlah iterasi maksimum.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 2: ST-SCKM -->
        <div id="st-sckm" class="tab-content">
            <div class="section-title">
                <i class="fas fa-clock"></i>
                <h2>ST-SCKM (Spatio-Temporal SCKM)</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">ST-SCKM memperluas konsep SCKM dengan menambahkan dimensi waktu. Algoritma ini cocok untuk data yang berubah seiring waktu seperti data sensor, lalu lintas, atau penyebaran penyakit.</p>
            
            <div class="formula-container">
                <h3 class="formula-title"><i class="fas fa-calculator"></i> Rumus ST-SCKM Objective Function</h3>
                <div class="formula">J = Σ<sub>t=1</sub><sup>T</sup> Σ<sub>i=1</sub><sup>n</sup> Σ<sub>j=1</sub><sup>k</sup> w<sub>ijt</sub> (||x<sub>it</sub> - c<sub>jt</sub>||² + α||t - t<sub>j</sub>||²) + λ Σ φ<sub>ijt</sub></div>
                <div class="formula-variables">
                    <div class="variable">
                        <strong>t</strong>: Waktu pengamatan
                    </div>
                    <div class="variable">
                        <strong>T</strong>: Total periode waktu
                    </div>
                    <div class="variable">
                        <strong>x<sub>it</sub></strong>: Titik data ke-i pada waktu t
                    </div>
                    <div class="variable">
                        <strong>c<sub>jt</sub></strong>: Centroid klaster ke-j pada waktu t
                    </div>
                    <div class="variable">
                        <strong>α</strong>: Parameter penyeimbang untuk komponen temporal
                    </div>
                    <div class="variable">
                        <strong>t<sub>j</sub></strong>: Waktu referensi untuk klaster j
                    </div>
                </div>
            </div>
            
            <div class="visualization-container">
                <!-- Visualisasi ST-SCKM 3D -->
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-cube"></i> Visualisasi ST-SCKM (3D: Ruang + Waktu)</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-st">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-st">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="st-sckm-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Klaster 1 (Waktu Awal)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Klaster 2 (Waktu Tengah)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Klaster 3 (Waktu Akhir)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #1A2980;"></div>
                            <span>Centroid (bergerak waktu)</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" id="prev-st">
                            <i class="fas fa-chevron-left"></i> Sebelumnya
                        </button>
                        <button class="btn btn-accent" id="next-st">
                            <i class="fas fa-chevron-right"></i> Berikutnya
                        </button>
                        <button class="btn btn-primary" id="run-st">
                            <i class="fas fa-play"></i> Jalankan Semua
                        </button>
                    </div>
                </div>
                
                <!-- Pergerakan Klaster dari Waktu ke Waktu -->
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-road"></i> Pergerakan Klaster dari Waktu ke Waktu</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-time">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="time-evolution-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Waktu t1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Waktu t2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Waktu t3</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <label for="time-slider" style="font-weight: 600; color: var(--primary);">Waktu: </label>
                        <input type="range" id="time-slider" min="1" max="3" value="1" step="1" style="width: 60%; margin: 0 15px;">
                        <span id="time-value" style="font-weight: 600; color: var(--secondary);">t = 1</span>
                    </div>
                </div>
            </div>
            
            <!-- Step-by-Step untuk ST-SCKM -->
            <div class="step-controls">
                <div class="step-info">
                    <h4 class="step-title" id="st-step-title">Langkah 1: Inisialisasi Multi-waktu</h4>
                    <p class="step-description" id="st-step-description">Tentukan parameter untuk setiap periode waktu yang dianalisis. Inisialisasi centroid untuk setiap waktu berdasarkan data awal.</p>
                </div>
                
                <div class="step-navigation">
                    <div class="step-counter">
                        Langkah: <span id="st-current-step">1</span> dari <span id="st-total-steps">5</span>
                    </div>
                    <div class="step-buttons">
                        <button class="btn btn-outline" id="prev-step-st">
                            <i class="fas fa-chevron-left"></i> Langkah Sebelumnya
                        </button>
                        <button class="btn btn-primary" id="next-step-st">
                            Langkah Berikutnya <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Langkah-langkah Algoritma ST-SCKM -->
            <div class="algorithm-steps-container">
                <h3 class="section-title" style="margin-top: 50px;">
                    <i class="fas fa-list-ol"></i>
                    <span>Langkah-langkah Algoritma ST-SCKM</span>
                </h3>
                
                <div class="algorithm-step active" id="st-step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Inisialisasi Multi-waktu</h4>
                        <p>Tentukan parameter untuk setiap periode waktu yang dianalisis. Inisialisasi centroid untuk setiap waktu berdasarkan data awal.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Penugasan Spatio-Temporal</h4>
                        <p>Titik ditugaskan ke klaster berdasarkan kedekatan ruang dan waktu. Titik yang lebih dekat secara temporal memiliki kemungkinan lebih besar untuk berada dalam klaster yang sama.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Pembaruan Centroid Dinamis</h4>
                        <p>Centroid diperbarui dengan mempertimbangkan posisi spasial dan perubahan temporal. Centroid pada waktu t mempengaruhi centroid pada waktu t+1.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Penghalusan Temporal</h4>
                        <p>Menerapkan smoothness constraint untuk menjaga konsistensi klaster antar waktu. Ini mencegah perubahan drastis dalam struktur klaster dari satu waktu ke waktu berikutnya.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-step-5">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h4>Konvergensi</h4>
                        <p>Iterasi hingga centroid stabil di semua dimensi (ruang dan waktu) atau mencapai jumlah iterasi maksimum yang ditentukan.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 3: Perbandingan -->
        <div id="comparison" class="tab-content">
            <div class="section-title">
                <i class="fas fa-balance-scale"></i>
                <h2>Perbandingan SCKM vs ST-SCKM</h2>
            </div>
            
            <p style="margin-bottom: 30px; font-size: 1.1rem; color: var(--dark);">Berikut adalah perbandingan mendetail antara algoritma SCKM dan ST-SCKM dalam berbagai aspek, termasuk dimensi data, kompleksitas, aplikasi, keunggulan, dan keterbatasan.</p>
            
            <div class="comparison-container">
                <!-- SCKM -->
                <div class="comparison-card">
                    <h3 class="comparison-title">
                        <i class="fas fa-map-marker-alt"></i>
                        SCKM (Spatially Constrained K-Means)
                    </h3>
                    
                    <ul class="comparison-list">
                        <li><strong>Dimensi:</strong> Hanya spasial (2D atau 3D)</li>
                        <li><strong>Batasan:</strong> Hanya batasan jarak spasial</li>
                        <li><strong>Kompleksitas:</strong> Relatif lebih sederhana</li>
                        <li><strong>Keunggulan:</strong> Menghasilkan klaster dengan kontinuitas spasial</li>
                        <li><strong>Keterbatasan:</strong> Tidak memperhitungkan perubahan waktu</li>
                        <li><strong>Waktu Eksekusi:</strong> Lebih cepat karena dimensi lebih sedikit</li>
                        <li><strong>Parameter Utama:</strong> k (jumlah klaster), ε (jarak maksimum), MinPts</li>
                        <li><strong>Kebutuhan Memori:</strong> Relatif lebih rendah</li>
                    </ul>
                    
                    <div style="margin-top: 25px; padding: 20px; background-color: rgba(255, 107, 107, 0.05); border-radius: 10px;">
                        <h4 style="color: var(--accent1); margin-bottom: 10px;">
                            <i class="fas fa-lightbulb"></i> Contoh Aplikasi:
                        </h4>
                        <ul style="list-style-type: none;">
                            <li style="padding: 5px 0;">• Segmentasi gambar satelit</li>
                            <li style="padding: 5px 0;">• Analisis pola kriminalitas wilayah</li>
                            <li style="padding: 5px 0;">• Pemetaan zona risiko bencana</li>
                            <li style="padding: 5px 0;">• Perencanaan tata kota</li>
                        </ul>
                    </div>
                </div>
                
                <!-- ST-SCKM -->
                <div class="comparison-card">
                    <h3 class="comparison-title">
                        <i class="fas fa-clock"></i>
                        ST-SCKM (Spatio-Temporal SCKM)
                    </h3>
                    
                    <ul class="comparison-list">
                        <li><strong>Dimensi:</strong> Spasial + Temporal (3D+Waktu)</li>
                        <li><strong>Batasan:</strong> Batasan spasial dan temporal</li>
                        <li><strong>Kompleksitas:</strong> Lebih kompleks karena dimensi tambahan</li>
                        <li><strong>Keunggulan:</strong> Dapat melacak perubahan pola seiring waktu</li>
                        <li><strong>Keterbatasan:</strong> Memerlukan lebih banyak data dan komputasi</li>
                        <li><strong>Waktu Eksekusi:</strong> Lebih lama karena dimensi tambahan</li>
                        <li><strong>Parameter Tambahan:</strong> α (weight temporal), T (periode waktu)</li>
                        <li><strong>Kebutuhan Memori:</strong> Lebih tinggi karena data time-series</li>
                    </ul>
                    
                    <div style="margin-top: 25px; padding: 20px; background-color: rgba(78, 205, 196, 0.05); border-radius: 10px;">
                        <h4 style="color: var(--accent2); margin-bottom: 10px;">
                            <i class="fas fa-lightbulb"></i> Contoh Aplikasi:
                        </h4>
                        <ul style="list-style-type: none;">
                            <li style="padding: 5px 0;">• Pelacakan penyebaran penyakit</li>
                            <li style="padding: 5px 0;">• Analisis pola lalu lintas waktu nyata</li>
                            <li style="padding: 5px 0;">• Pemantauan perubahan iklim regional</li>
                            <li style="padding: 5px 0;">• Prediksi pergerakan kerumunan</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Contoh Aplikasi Nyata -->
            <div style="margin-top: 50px; background-color: white; padding: 35px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);">
                <h3 class="section-title" style="margin-bottom: 30px;">
                    <i class="fas fa-chart-line"></i>
                    <span>Contoh Aplikasi Nyata</span>
                </h3>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 30px;">
                    <div style="padding: 25px; background: linear-gradient(135deg, rgba(255, 107, 107, 0.05), rgba(255, 107, 107, 0.1)); border-radius: 12px; border-left: 5px solid var(--accent1);">
                        <h4 style="color: var(--accent1); margin-bottom: 15px; font-size: 1.3rem;">
                            <i class="fas fa-map-marked-alt"></i> SCKM dalam Pemetaan Zona Risiko Banjir
                        </h4>
                        <p>SCKM digunakan untuk mengelompokkan daerah berdasarkan kedekatan geografis dan karakteristik tanah. Daerah dengan karakteristik serupa dan saling berdekatan dikelompokkan sebagai zona risiko yang sama. Hasilnya membantu dalam perencanaan mitigasi bencana yang lebih efektif.</p>
                    </div>
                    
                    <div style="padding: 25px; background: linear-gradient(135deg, rgba(78, 205, 196, 0.05), rgba(78, 205, 196, 0.1)); border-radius: 12px; border-left: 5px solid var(--accent2);">
                        <h4 style="color: var(--accent2); margin-bottom: 15px; font-size: 1.3rem;">
                            <i class="fas fa-virus"></i> ST-SCKM dalam Pelacakan Penyebaran Penyakit
                        </h4>
                        <p>ST-SCKM dapat mengelompokkan daerah berdasarkan pola penyebaran penyakit dari waktu ke waktu. Klaster menunjukkan bagaimana penyakit menyebar secara geografis seiring berjalannya waktu, membantu identifikasi hotspot penyebaran dan prediksi area risiko berikutnya untuk intervensi yang tepat waktu.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p style="font-size: 1.1rem; margin-bottom: 10px;">Visualisasi SCKM & ST-SCKM | Dikembangkan untuk Penjelasan Algoritma Klastering Spasial-Temporal</p>
            <p style="color: var(--gray);">Konsep: MinPts, Core Points, Border Points, Noise Points, Batasan Spasial & Temporal</p>
            <div style="margin-top: 20px; display: flex; justify-content: center; gap: 20px;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-save" style="color: var(--primary);"></i>
                    <span>Save Gambar</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-play-circle" style="color: var(--secondary);"></i>
                    <span>Step-by-Step</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-chart-line" style="color: var(--accent1);"></i>
                    <span>Visualisasi Interaktif</span>
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Tab switching functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and tab contents
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
                
                // Trigger resize for canvases
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 100);
            });
        });
        
        // SCKM Visualization
        const sckmCanvas = document.getElementById('sckm-canvas');
        const sckmCtx = sckmCanvas.getContext('2d');
        let sckmPoints = [];
        let sckmClusters = [];
        let sckmCentroids = [];
        let sckmStep = 0;
        let sckmTotalSteps = 5;
        
        // Step descriptions for SCKM
        const sckmStepTitles = [
            "Langkah 1: Inisialisasi",
            "Langkah 2: Batasan Spasial",
            "Langkah 3: Penugasan Titik",
            "Langkah 4: Pembaruan Centroid",
            "Langkah 5: Konvergensi"
        ];
        
        const sckmStepDescriptions = [
            "Tentukan jumlah klaster (k) dan parameter spasial (jarak maksimum antara titik dan centroid). Posisikan centroid secara acak atau dengan metode tertentu.",
            "Area pengaruh setiap centroid ditentukan oleh batasan spasial. Titik yang berada di luar batasan semua centroid akan dianggap sebagai noise.",
            "Setiap titik ditugaskan ke centroid terdekat yang masih dalam batasan jarak spasial. Titik yang tidak memenuhi batasan ditandai sebagai noise.",
            "Posisi centroid diperbarui berdasarkan rata-rata titik-titik yang ditugaskan ke klaster tersebut.",
            "Proses penugasan dan pembaruan centroid diulang hingga konvergen (tidak ada perubahan signifikan) atau mencapai iterasi maksimum."
        ];
        
        // Initialize SCKM visualization
        function initSCKM() {
            sckmPoints = [];
            sckmClusters = [[], [], []];
            sckmCentroids = [
                {x: 150, y: 150, color: '#1A2980'},
                {x: 350, y: 150, color: '#1A2980'},
                {x: 250, y: 300, color: '#1A2980'}
            ];
            sckmStep = 0;
            
            // Generate random points with some structure
            for (let i = 0; i < 60; i++) {
                // Create points around centroids
                const clusterIdx = Math.floor(Math.random() * 3);
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 80 + 20;
                
                const x = sckmCentroids[clusterIdx].x + Math.cos(angle) * distance;
                const y = sckmCentroids[clusterIdx].y + Math.sin(angle) * distance;
                
                // Determine point type: core, border, or noise
                let type, color;
                const distToCentroid = Math.sqrt(
                    Math.pow(x - sckmCentroids[clusterIdx].x, 2) + 
                    Math.pow(y - sckmCentroids[clusterIdx].y, 2)
                );
                
                if (distToCentroid < 50) {
                    type = 'core';
                    color = '#FF6B6B';
                } else if (distToCentroid < 100) {
                    type = 'border';
                    color = '#4ECDC4';
                } else {
                    type = 'noise';
                    color = '#FFD166';
                }
                
                // Add some noise points
                if (Math.random() < 0.1) {
                    type = 'noise';
                    color = '#FFD166';
                    sckmPoints.push({
                        x: Math.random() * 550,
                        y: Math.random() * 400,
                        originalCluster: clusterIdx,
                        currentCluster: -1,
                        type: type,
                        color: color
                    });
                } else {
                    sckmPoints.push({
                        x: x,
                        y: y,
                        originalCluster: clusterIdx,
                        currentCluster: -1,
                        type: type,
                        color: color
                    });
                }
            }
            
            updateSCKMStepInfo();
            updateAlgorithmSteps();
            drawSCKM();
        }
        
        // Draw SCKM visualization
        function drawSCKM() {
            sckmCtx.clearRect(0, 0, sckmCanvas.width, sckmCanvas.height);
            
            // Draw spatial constraints (circles around centroids)
            if (sckmStep > 0) {
                sckmCentroids.forEach(centroid => {
                    sckmCtx.beginPath();
                    sckmCtx.arc(centroid.x, centroid.y, 120, 0, Math.PI * 2);
                    sckmCtx.strokeStyle = 'rgba(26, 41, 128, 0.2)';
                    sckmCtx.lineWidth = 2;
                    sckmCtx.setLineDash([5, 5]);
                    sckmCtx.stroke();
                    sckmCtx.setLineDash([]);
                    
                    // Add label for spatial constraint
                    sckmCtx.fillStyle = 'rgba(26, 41, 128, 0.6)';
                    sckmCtx.font = '12px Arial';
                    sckmCtx.fillText('ε = 120', centroid.x + 130, centroid.y - 10);
                });
            }
            
            // Draw points
            sckmPoints.forEach(point => {
                sckmCtx.beginPath();
                sckmCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                sckmCtx.fillStyle = point.color;
                sckmCtx.fill();
                
                // Draw border for core points
                if (point.type === 'core') {
                    sckmCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    sckmCtx.lineWidth = 1.5;
                    sckmCtx.stroke();
                }
            });
            
            // Draw centroids
            sckmCentroids.forEach(centroid => {
                sckmCtx.beginPath();
                sckmCtx.arc(centroid.x, centroid.y, 10, 0, Math.PI * 2);
                sckmCtx.fillStyle = centroid.color;
                sckmCtx.fill();
                
                // Add glow effect
                sckmCtx.shadowColor = centroid.color;
                sckmCtx.shadowBlur = 15;
                sckmCtx.fill();
                sckmCtx.shadowBlur = 0;
                
                sckmCtx.strokeStyle = '#FFF';
                sckmCtx.lineWidth = 2;
                sckmCtx.stroke();
                
                // Draw cross inside centroid
                sckmCtx.beginPath();
                sckmCtx.moveTo(centroid.x - 5, centroid.y);
                sckmCtx.lineTo(centroid.x + 5, centroid.y);
                sckmCtx.moveTo(centroid.x, centroid.y - 5);
                sckmCtx.lineTo(centroid.x, centroid.y + 5);
                sckmCtx.strokeStyle = '#FFF';
                sckmCtx.lineWidth = 2;
                sckmCtx.stroke();
            });
            
            // Draw lines from points to centroids if step > 1
            if (sckmStep > 1) {
                sckmPoints.forEach(point => {
                    const centroid = sckmCentroids[point.currentCluster >= 0 ? point.currentCluster : point.originalCluster];
                    sckmCtx.beginPath();
                    sckmCtx.moveTo(point.x, point.y);
                    sckmCtx.lineTo(centroid.x, centroid.y);
                    sckmCtx.strokeStyle = 'rgba(26, 41, 128, 0.3)';
                    sckmCtx.lineWidth = 1;
                    sckmCtx.stroke();
                });
            }
            
            // Draw step description
            sckmCtx.fillStyle = '#2d3748';
            sckmCtx.font = 'bold 16px Arial';
            sckmCtx.fillText(`SCKM - Langkah ${sckmStep + 1}/${sckmTotalSteps}`, 20, 30);
            
            const stepText = [
                '1. Inisialisasi: Titik data dan centroid awal',
                '2. Batasan Spasial: Area pengaruh setiap centroid (ε = 120)',
                '3. Penugasan: Titik ditugaskan ke centroid terdekat dalam batasan',
                '4. Pembaruan: Centroid diperbarui berdasarkan titik dalam klaster',
                '5. Konvergensi: Proses berulang hingga stabil'
            ];
            
            if (sckmStep < stepText.length) {
                sckmCtx.fillStyle = '#718096';
                sckmCtx.font = '14px Arial';
                sckmCtx.fillText(stepText[sckmStep], 20, 60);
            }
        }
        
        // Update SCKM step information
        function updateSCKMStepInfo() {
            document.getElementById('sckm-step-title').textContent = sckmStepTitles[sckmStep];
            document.getElementById('sckm-step-description').textContent = sckmStepDescriptions[sckmStep];
            document.getElementById('sckm-current-step').textContent = sckmStep + 1;
            document.getElementById('sckm-total-steps').textContent = sckmTotalSteps;
            
            // Update button states
            document.getElementById('prev-sckm').disabled = sckmStep === 0;
            document.getElementById('prev-step-sckm').disabled = sckmStep === 0;
            document.getElementById('next-sckm').disabled = sckmStep === sckmTotalSteps - 1;
            document.getElementById('next-step-sckm').disabled = sckmStep === sckmTotalSteps - 1;
        }
        
        // Update algorithm steps highlighting
        function updateAlgorithmSteps() {
            // Reset all steps
            for (let i = 1; i <= 5; i++) {
                const stepEl = document.getElementById(`step-${i}`);
                stepEl.classList.remove('active');
            }
            
            // Highlight current step
            if (sckmStep >= 0 && sckmStep < 5) {
                const currentStepEl = document.getElementById(`step-${sckmStep + 1}`);
                currentStepEl.classList.add('active');
            }
        }
        
        // Step through SCKM algorithm
        function stepSCKM() {
            if (sckmStep < sckmTotalSteps) {
                sckmStep++;
                
                // Perform actions based on step
                if (sckmStep === 2) {
                    // Show spatial constraints
                } else if (sckmStep === 3) {
                    // Assign points to nearest centroid within constraint
                    sckmPoints.forEach(point => {
                        let minDist = Infinity;
                        let closestCentroid = -1;
                        
                        sckmCentroids.forEach((centroid, idx) => {
                            const dist = Math.sqrt(
                                Math.pow(point.x - centroid.x, 2) + 
                                Math.pow(point.y - centroid.y, 2)
                            );
                            
                            // Check if within spatial constraint (120 pixels)
                            if (dist < 120 && dist < minDist) {
                                minDist = dist;
                                closestCentroid = idx;
                            }
                        });
                        
                        point.currentCluster = closestCentroid;
                        
                        // Update point color based on assignment
                        if (closestCentroid === 0) {
                            point.color = '#FF6B6B';
                        } else if (closestCentroid === 1) {
                            point.color = '#4ECDC4';
                        } else if (closestCentroid === 2) {
                            point.color = '#FFD166';
                        }
                    });
                } else if (sckmStep === 4) {
                    // Update centroids
                    const clusterSums = [{x: 0, y: 0, count: 0}, {x: 0, y: 0, count: 0}, {x: 0, y: 0, count: 0}];
                    
                    sckmPoints.forEach(point => {
                        if (point.currentCluster >= 0) {
                            clusterSums[point.currentCluster].x += point.x;
                            clusterSums[point.currentCluster].y += point.y;
                            clusterSums[point.currentCluster].count++;
                        }
                    });
                    
                    clusterSums.forEach((sum, idx) => {
                        if (sum.count > 0) {
                            sckmCentroids[idx].x = sum.x / sum.count;
                            sckmCentroids[idx].y = sum.y / sum.count;
                        }
                    });
                } else if (sckmStep === 5) {
                    // Converge - move centroids slightly to show convergence
                    sckmCentroids.forEach(centroid => {
                        centroid.x += (Math.random() * 20 - 10);
                        centroid.y += (Math.random() * 20 - 10);
                    });
                }
                
                updateSCKMStepInfo();
                updateAlgorithmSteps();
                drawSCKM();
            }
        }
        
        // Step backward in SCKM algorithm
        function prevStepSCKM() {
            if (sckmStep > 0) {
                sckmStep--;
                
                // If going back from step 3, reset point assignments
                if (sckmStep === 2) {
                    sckmPoints.forEach(point => {
                        point.currentCluster = -1;
                        // Reset point colors
                        const distToCentroid = Math.sqrt(
                            Math.pow(point.x - sckmCentroids[point.originalCluster].x, 2) + 
                            Math.pow(point.y - sckmCentroids[point.originalCluster].y, 2)
                        );
                        
                        if (distToCentroid < 50) {
                            point.color = '#FF6B6B';
                        } else if (distToCentroid < 100) {
                            point.color = '#4ECDC4';
                        } else {
                            point.color = '#FFD166';
                        }
                    });
                }
                
                // If going back from step 4, reset centroids
                if (sckmStep === 3) {
                    sckmCentroids = [
                        {x: 150, y: 150, color: '#1A2980'},
                        {x: 350, y: 150, color: '#1A2980'},
                        {x: 250, y: 300, color: '#1A2980'}
                    ];
                }
                
                updateSCKMStepInfo();
                updateAlgorithmSteps();
                drawSCKM();
            }
        }
        
        // Run all SCKM steps automatically
        function runAllSCKM() {
            // Reset to step 0
            sckmStep = 0;
            initSCKM();
            
            // Run through all steps with delays
            for (let i = 0; i < sckmTotalSteps; i++) {
                setTimeout(() => {
                    stepSCKM();
                }, i * 1500);
            }
        }
        
        // MinPts Visualization
        const minptsCanvas = document.getElementById('minpts-canvas');
        const minptsCtx = minptsCanvas.getContext('2d');
        let minptsPoints = [];
        let showRadius = false;
        
        function initMinPts() {
            minptsPoints = [];
            showRadius = false;
            
            // Create core point with surrounding points
            const coreX = 275, coreY = 200;
            
            // Add core point
            minptsPoints.push({
                x: coreX,
                y: coreY,
                type: 'core',
                color: '#FF6B6B'
            });
            
            // Add points around core (within radius)
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 40;
                
                minptsPoints.push({
                    x: coreX + Math.cos(angle) * distance,
                    y: coreY + Math.sin(angle) * distance,
                    type: Math.random() > 0.3 ? 'core' : 'border',
                    color: Math.random() > 0.3 ? '#FF6B6B' : '#4ECDC4'
                });
            }
            
            // Add some border points further away
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 60 + 50;
                
                minptsPoints.push({
                    x: coreX + Math.cos(angle) * distance,
                    y: coreY + Math.sin(angle) * distance,
                    type: 'border',
                    color: '#4ECDC4'
                });
            }
            
            // Add noise points
            for (let i = 0; i < 4; i++) {
                minptsPoints.push({
                    x: Math.random() * 550,
                    y: Math.random() * 400,
                    type: 'noise',
                    color: '#FFD166'
                });
            }
            
            drawMinPts();
        }
        
        function drawMinPts() {
            minptsCtx.clearRect(0, 0, minptsCanvas.width, minptsCanvas.height);
            
            // Draw radius circle if shown
            if (showRadius) {
                minptsCtx.beginPath();
                minptsCtx.arc(275, 200, 50, 0, Math.PI * 2);
                minptsCtx.strokeStyle = 'rgba(26, 41, 128, 0.3)';
                minptsCtx.lineWidth = 2;
                minptsCtx.setLineDash([5, 5]);
                minptsCtx.stroke();
                minptsCtx.setLineDash([]);
                
                minptsCtx.fillStyle = '#1A2980';
                minptsCtx.font = '14px Arial';
                minptsCtx.fillText('Radius (ε = 50)', 290, 140);
                
                // Draw lines to show connections
                minptsPoints.forEach(point => {
                    const dist = Math.sqrt(Math.pow(point.x - 275, 2) + Math.pow(point.y - 200, 2));
                    if (dist <= 50 && point.type !== 'noise') {
                        minptsCtx.beginPath();
                        minptsCtx.moveTo(275, 200);
                        minptsCtx.lineTo(point.x, point.y);
                        minptsCtx.strokeStyle = 'rgba(26, 41, 128, 0.2)';
                        minptsCtx.lineWidth = 1;
                        minptsCtx.stroke();
                    }
                });
            }
            
            // Draw points
            minptsPoints.forEach(point => {
                minptsCtx.beginPath();
                minptsCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                minptsCtx.fillStyle = point.color;
                minptsCtx.fill();
                
                if (point.type === 'core') {
                    minptsCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    minptsCtx.lineWidth = 1.5;
                    minptsCtx.stroke();
                }
            });
            
            // Draw legend/text
            minptsCtx.fillStyle = '#2d3748';
            minptsCtx.font = 'bold 16px Arial';
            minptsCtx.fillText('Konsep MinPts = 5', 20, 30);
            
            minptsCtx.fillStyle = '#718096';
            minptsCtx.font = '14px Arial';
            minptsCtx.fillText('Core: ≥ 5 titik dalam radius ε', 20, 60);
            minptsCtx.fillText('Border: Terhubung ke core tapi < 5 tetangga', 20, 85);
            minptsCtx.fillText('Noise: Tidak terhubung ke core', 20, 110);
            
            // Count points in radius
            if (showRadius) {
                const pointsInRadius = minptsPoints.filter(p => {
                    const dist = Math.sqrt(Math.pow(p.x - 275, 2) + Math.pow(p.y - 200, 2));
                    return dist <= 50 && p.type !== 'noise';
                }).length;
                
                minptsCtx.fillStyle = pointsInRadius >= 5 ? '#FF6B6B' : '#4ECDC4';
                minptsCtx.font = 'bold 16px Arial';
                minptsCtx.fillText(`Titik dalam radius: ${pointsInRadius}`, 20, 360);
                
                if (pointsInRadius >= 5) {
                    minptsCtx.fillText('✓ Titik pusat adalah Core Point', 20, 390);
                } else {
                    minptsCtx.fillText('✗ Titik pusat BUKAN Core Point', 20, 390);
                }
            }
        }
        
        // ST-SCKM Visualization
        const stCanvas = document.getElementById('st-sckm-canvas');
        const stCtx = stCanvas.getContext('2d');
        let stPoints = [];
        let stCentroids = [];
        let stStep = 0;
        let stTotalSteps = 5;
        
        // Step descriptions for ST-SCKM
        const stStepTitles = [
            "Langkah 1: Inisialisasi Multi-waktu",
            "Langkah 2: Batasan Spatio-Temporal",
            "Langkah 3: Penghubungan Temporal",
            "Langkah 4: Penugasan dengan Waktu",
            "Langkah 5: Konvergensi"
        ];
        
        const stStepDescriptions = [
            "Data dengan dimensi ruang dan waktu diinisialisasi. Centroid ditentukan untuk setiap periode waktu.",
            "Batasan Spatio-Temporal diterapkan, mempertimbangkan jarak spasial dan kedekatan temporal.",
            "Penghubungan temporal antar klaster menunjukkan bagaimana klaster berevolusi dari waktu ke waktu.",
            "Titik ditugaskan ke klaster dengan mempertimbangkan kedekatan spasial dan temporal.",
            "Konvergensi dengan smoothness constraint menjaga konsistensi klaster antar waktu."
        ];
        
        function initSTSCKM() {
            stPoints = [];
            stCentroids = [
                {x: 150, y: 150, time: 1, color: '#1A2980'},
                {x: 350, y: 150, time: 2, color: '#1A2980'},
                {x: 250, y: 300, time: 3, color: '#1A2980'}
            ];
            stStep = 0;
            
            // Generate points for each time period
            for (let t = 1; t <= 3; t++) {
                for (let i = 0; i < 20; i++) {
                    // Choose a centroid to cluster around
                    const centroidIdx = Math.floor(Math.random() * 3);
                    const centroid = stCentroids[centroidIdx];
                    
                    // Points drift over time
                    const timeFactor = t * 0.3;
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 60 + 20;
                    
                    const baseX = centroid.x + (centroidIdx === 1 ? 50 * timeFactor : 0);
                    const baseY = centroid.y + (centroidIdx === 2 ? -30 * timeFactor : 0);
                    
                    const x = baseX + Math.cos(angle) * distance;
                    const y = baseY + Math.sin(angle) * distance;
                    
                    // Color based on time
                    let color;
                    if (t === 1) color = '#FF6B6B';
                    else if (t === 2) color = '#4ECDC4';
                    else color = '#FFD166';
                    
                    stPoints.push({
                        x: x,
                        y: y,
                        time: t,
                        originalCluster: centroidIdx,
                        color: color,
                        centroidX: centroid.x,
                        centroidY: centroid.y
                    });
                }
            }
            
            updateSTStepInfo();
            updateSTAlgorithmSteps();
            drawSTSCKM();
        }
        
        function drawSTSCKM() {
            stCtx.clearRect(0, 0, stCanvas.width, stCanvas.height);
            
            // Draw time dimension representation
            stCtx.fillStyle = '#2d3748';
            stCtx.font = 'bold 16px Arial';
            stCtx.fillText(`ST-SCKM - Langkah ${stStep + 1}/${stTotalSteps}`, 20, 30);
            
            // Time indicator
            stCtx.fillStyle = '#718096';
            stCtx.font = '14px Arial';
            stCtx.fillText('Dimensi Waktu:', 20, 60);
            
            for (let t = 1; t <= 3; t++) {
                const x = 140 + (t-1)*40;
                stCtx.fillStyle = t === 1 ? '#FF6B6B' : t === 2 ? '#4ECDC4' : '#FFD166';
                stCtx.fillRect(x, 50, 30, 10);
                stCtx.fillStyle = '#2d3748';
                stCtx.font = '14px Arial';
                stCtx.fillText(`t${t}`, x + 5, 75);
            }
            
            // Draw spatio-temporal constraints if step > 0
            if (stStep > 0) {
                stCentroids.forEach(centroid => {
                    // Draw spatial constraint
                    stCtx.beginPath();
                    stCtx.arc(centroid.x, centroid.y, 100, 0, Math.PI * 2);
                    stCtx.strokeStyle = 'rgba(26, 41, 128, 0.2)';
                    stCtx.lineWidth = 2;
                    stCtx.setLineDash([5, 5]);
                    stCtx.stroke();
                    stCtx.setLineDash([]);
                    
                    // Draw temporal connection if step > 1
                    if (stStep > 1) {
                        stCtx.beginPath();
                        stCtx.moveTo(centroid.x - 5, centroid.y - 5);
                        stCtx.lineTo(centroid.x + 50, centroid.y - 50);
                        stCtx.strokeStyle = 'rgba(26, 41, 128, 0.3)';
                        stCtx.lineWidth = 2;
                        stCtx.stroke();
                    }
                });
            }
            
            // Draw points
            stPoints.forEach(point => {
                stCtx.beginPath();
                stCtx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                stCtx.fillStyle = point.color;
                stCtx.fill();
                
                // Connect points to their centroid if step > 2
                if (stStep > 2) {
                    stCtx.beginPath();
                    stCtx.moveTo(point.x, point.y);
                    stCtx.lineTo(point.centroidX, point.centroidY);
                    stCtx.strokeStyle = 'rgba(26, 41, 128, 0.1)';
                    stCtx.lineWidth = 1;
                    stCtx.stroke();
                }
            });
            
            // Draw centroids with time dimension
            stCentroids.forEach(centroid => {
                // Draw centroid with time indicator
                stCtx.beginPath();
                stCtx.arc(centroid.x, centroid.y, 8, 0, Math.PI * 2);
                stCtx.fillStyle = centroid.color;
                stCtx.fill();
                
                // Add glow effect
                stCtx.shadowColor = centroid.color;
                stCtx.shadowBlur = 15;
                stCtx.fill();
                stCtx.shadowBlur = 0;
                
                // Draw time indicator on centroid
                stCtx.fillStyle = centroid.time === 1 ? '#FF6B6B' : 
                                 centroid.time === 2 ? '#4ECDC4' : '#FFD166';
                stCtx.beginPath();
                stCtx.arc(centroid.x, centroid.y, 4, 0, Math.PI * 2);
                stCtx.fill();
                
                // Draw cross inside centroid
                stCtx.beginPath();
                stCtx.moveTo(centroid.x - 4, centroid.y);
                stCtx.lineTo(centroid.x + 4, centroid.y);
                stCtx.moveTo(centroid.x, centroid.y - 4);
                stCtx.lineTo(centroid.x, centroid.y + 4);
                stCtx.strokeStyle = '#FFF';
                stCtx.lineWidth = 1;
                stCtx.stroke();
            });
            
            // Draw step description
            const stepText = [
                '1. Data dengan dimensi ruang dan waktu',
                '2. Batasan Spatio-Temporal diterapkan',
                '3. Penghubungan temporal antar klaster',
                '4. Penugasan titik dengan mempertimbangkan waktu',
                '5. Konvergensi dengan smoothness constraint'
            ];
            
            if (stStep < stepText.length) {
                stCtx.fillStyle = '#718096';
                stCtx.font = '14px Arial';
                stCtx.fillText(stepText[stStep], 20, 380);
            }
        }
        
        // Update ST-SCKM step information
        function updateSTStepInfo() {
            document.getElementById('st-step-title').textContent = stStepTitles[stStep];
            document.getElementById('st-step-description').textContent = stStepDescriptions[stStep];
            document.getElementById('st-current-step').textContent = stStep + 1;
            document.getElementById('st-total-steps').textContent = stTotalSteps;
            
            // Update button states
            document.getElementById('prev-st').disabled = stStep === 0;
            document.getElementById('prev-step-st').disabled = stStep === 0;
            document.getElementById('next-st').disabled = stStep === stTotalSteps - 1;
            document.getElementById('next-step-st').disabled = stStep === stTotalSteps - 1;
        }
        
        // Update ST algorithm steps highlighting
        function updateSTAlgorithmSteps() {
            // Reset all steps
            for (let i = 1; i <= 5; i++) {
                const stepEl = document.getElementById(`st-step-${i}`);
                stepEl.classList.remove('active');
            }
            
            // Highlight current step
            if (stStep >= 0 && stStep < 5) {
                const currentStepEl = document.getElementById(`st-step-${stStep + 1}`);
                currentStepEl.classList.add('active');
            }
        }
        
        function stepSTSCKM() {
            if (stStep < stTotalSteps) {
                stStep++;
                
                // Move centroids to show temporal evolution
                if (stStep >= 3) {
                    stCentroids.forEach(centroid => {
                        centroid.x += 10;
                        centroid.y += (centroid.time === 2 ? 5 : -5);
                    });
                    
                    // Update points to follow centroids
                    stPoints.forEach(point => {
                        if (point.time === stStep - 1) {
                            point.x += 10;
                            point.y += (point.originalCluster === 1 ? 5 : -5);
                        }
                    });
                }
                
                updateSTStepInfo();
                updateSTAlgorithmSteps();
                drawSTSCKM();
            }
        }
        
        // Step backward in ST-SCKM algorithm
        function prevStepST() {
            if (stStep > 0) {
                stStep--;
                
                // Move centroids back
                if (stStep >= 2) {
                    stCentroids.forEach(centroid => {
                        centroid.x -= 10;
                        centroid.y -= (centroid.time === 2 ? 5 : -5);
                    });
                    
                    // Update points to follow centroids back
                    stPoints.forEach(point => {
                        if (point.time === stStep) {
                            point.x -= 10;
                            point.y -= (point.originalCluster === 1 ? 5 : -5);
                        }
                    });
                }
                
                updateSTStepInfo();
                updateSTAlgorithmSteps();
                drawSTSCKM();
            }
        }
        
        // Run all ST-SCKM steps automatically
        function runAllST() {
            // Reset to step 0
            stStep = 0;
            initSTSCKM();
            
            // Run through all steps with delays
            for (let i = 0; i < stTotalSteps; i++) {
                setTimeout(() => {
                    stepSTSCKM();
                }, i * 1500);
            }
        }
        
        // Time Evolution Visualization
        const timeCanvas = document.getElementById('time-evolution-canvas');
        const timeCtx = timeCanvas.getContext('2d');
        const timeSlider = document.getElementById('time-slider');
        const timeValue = document.getElementById('time-value');
        
        let currentTime = 1;
        
        function drawTimeEvolution() {
            timeCtx.clearRect(0, 0, timeCanvas.width, timeCanvas.height);
            
            // Draw title
            timeCtx.fillStyle = '#2d3748';
            timeCtx.font = 'bold 16px Arial';
            timeCtx.fillText(`Pergerakan Klaster dari Waktu ke Waktu (t=${currentTime})`, 20, 30);
            
            // Draw clusters at current time
            const colors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
            
            for (let c = 0; c < 3; c++) {
                const centerX = 100 + c * 150;
                const centerY = 150 + (currentTime - 1) * 30;
                
                // Draw cluster center
                timeCtx.beginPath();
                timeCtx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                timeCtx.fillStyle = colors[c];
                timeCtx.fill();
                
                // Add glow effect
                timeCtx.shadowColor = colors[c];
                timeCtx.shadowBlur = 15;
                timeCtx.fill();
                timeCtx.shadowBlur = 0;
                
                timeCtx.strokeStyle = '#333';
                timeCtx.lineWidth = 2;
                timeCtx.stroke();
                
                // Draw cluster label
                timeCtx.fillStyle = '#333';
                timeCtx.font = '14px Arial';
                timeCtx.fillText(`Klaster ${c+1}`, centerX - 20, centerY - 20);
                
                // Draw points in cluster
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 40 + 20;
                    const pointX = centerX + Math.cos(angle) * distance;
                    const pointY = centerY + Math.sin(angle) * distance;
                    
                    timeCtx.beginPath();
                    timeCtx.arc(pointX, pointY, 5, 0, Math.PI * 2);
                    timeCtx.fillStyle = colors[c];
                    timeCtx.fill();
                }
            }
            
            // Draw time axis
            timeCtx.beginPath();
            timeCtx.moveTo(50, 250);
            timeCtx.lineTo(500, 250);
            timeCtx.strokeStyle = '#718096';
            timeCtx.lineWidth = 2;
            timeCtx.stroke();
            
            // Draw time markers
            for (let t = 1; t <= 3; t++) {
                const x = 100 + (t-1) * 150;
                timeCtx.beginPath();
                timeCtx.moveTo(x, 245);
                timeCtx.lineTo(x, 255);
                timeCtx.strokeStyle = '#718096';
                timeCtx.lineWidth = 2;
                timeCtx.stroke();
                
                timeCtx.fillStyle = '#2d3748';
                timeCtx.font = '14px Arial';
                timeCtx.fillText(`t${t}`, x - 5, 270);
                
                // Highlight current time
                if (t === currentTime) {
                    timeCtx.beginPath();
                    timeCtx.arc(x, 250, 8, 0, Math.PI * 2);
                    timeCtx.fillStyle = '#1A2980';
                    timeCtx.fill();
                    
                    // Add pulse animation
                    timeCtx.beginPath();
                    timeCtx.arc(x, 250, 12, 0, Math.PI * 2);
                    timeCtx.strokeStyle = 'rgba(26, 41, 128, 0.5)';
                    timeCtx.lineWidth = 2;
                    timeCtx.stroke();
                }
            }
            
            // Draw arrows showing evolution
            if (currentTime > 1) {
                timeCtx.strokeStyle = '#1A2980';
                timeCtx.lineWidth = 2;
                timeCtx.setLineDash([5, 3]);
                
                for (let c = 0; c < 3; c++) {
                    const startX = 100 + c * 150 - 100;
                    const startY = 150 + (currentTime - 2) * 30;
                    const endX = 100 + c * 150;
                    const endY = 150 + (currentTime - 1) * 30;
                    
                    timeCtx.beginPath();
                    timeCtx.moveTo(startX, startY);
                    timeCtx.lineTo(endX, endY);
                    timeCtx.stroke();
                    
                    // Draw arrowhead
                    drawArrow(timeCtx, endX, endY, startX, startY);
                }
                
                timeCtx.setLineDash([]);
            }
            
            // Draw explanation
            timeCtx.fillStyle = '#718096';
            timeCtx.font = '14px Arial';
            timeCtx.fillText('Geser slider untuk melihat perubahan klaster dari waktu t1 ke t3', 20, 350);
            
            const explanations = [
                't1: Inisialisasi klaster pada waktu awal',
                't2: Klaster mulai bergerak dan berubah bentuk',
                't3: Klaster telah berevolusi, beberapa titik berpindah klaster'
            ];
            
            timeCtx.fillText(explanations[currentTime-1], 20, 380);
        }
        
        function drawArrow(ctx, fromX, fromY, toX, toY) {
            const headlen = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI/6), toY - headlen * Math.sin(angle - Math.PI/6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI/6), toY - headlen * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }
        
        // Save image function
        function saveImage(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            // Show notification
            showSaveNotification();
        }
        
        // Show save notification
        function showSaveNotification() {
            const notification = document.createElement('div');
            notification.className = 'save-notification';
            notification.innerHTML = `
                <i class="fas fa-check-circle"></i>
                <span>Gambar berhasil disimpan!</span>
            `;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Initialize all visualizations
        initSCKM();
        initMinPts();
        initSTSCKM();
        drawTimeEvolution();
        
        // Event listeners for SCKM
        document.getElementById('reset-sckm').addEventListener('click', initSCKM);
        document.getElementById('prev-sckm').addEventListener('click', prevStepSCKM);
        document.getElementById('next-sckm').addEventListener('click', stepSCKM);
        document.getElementById('run-sckm').addEventListener('click', runAllSCKM);
        
        document.getElementById('prev-step-sckm').addEventListener('click', prevStepSCKM);
        document.getElementById('next-step-sckm').addEventListener('click', stepSCKM);
        
        // Event listeners for MinPts
        document.getElementById('reset-minpts').addEventListener('click', initMinPts);
        document.getElementById('add-point').addEventListener('click', function() {
            minptsPoints.push({
                x: Math.random() * 550,
                y: Math.random() * 400,
                type: Math.random() > 0.7 ? 'core' : Math.random() > 0.5 ? 'border' : 'noise',
                color: Math.random() > 0.7 ? '#FF6B6B' : Math.random() > 0.5 ? '#4ECDC4' : '#FFD166'
            });
            drawMinPts();
        });
        
        document.getElementById('show-radius').addEventListener('click', function() {
            showRadius = !showRadius;
            drawMinPts();
        });
        
        // Event listeners for ST-SCKM
        document.getElementById('reset-st').addEventListener('click', initSTSCKM);
        document.getElementById('prev-st').addEventListener('click', prevStepST);
        document.getElementById('next-st').addEventListener('click', stepSTSCKM);
        document.getElementById('run-st').addEventListener('click', runAllST);
        
        document.getElementById('prev-step-st').addEventListener('click', prevStepST);
        document.getElementById('next-step-st').addEventListener('click', stepSTSCKM);
        
        // Event listener for time slider
        timeSlider.addEventListener('input', function() {
            currentTime = parseInt(this.value);
            timeValue.textContent = `t = ${currentTime}`;
            drawTimeEvolution();
        });
        
        // Save image buttons
        document.getElementById('save-sckm').addEventListener('click', () => saveImage('sckm-canvas', 'sckm-visualization.png'));
        document.getElementById('save-minpts').addEventListener('click', () => saveImage('minpts-canvas', 'minpts-concept.png'));
        document.getElementById('save-st').addEventListener('click', () => saveImage('st-sckm-canvas', 'st-sckm-visualization.png'));
        document.getElementById('save-time').addEventListener('click', () => saveImage('time-evolution-canvas', 'time-evolution.png'));
        
        // Add floating animation to badges
        const badges = document.querySelectorAll('.badge');
        badges.forEach((badge, index) => {
            badge.style.animation = `float 3s ease-in-out ${index * 0.5}s infinite`;
        });
        
        // Add hover effects to algorithm steps
        const algorithmSteps = document.querySelectorAll('.algorithm-step');
        algorithmSteps.forEach(step => {
            step.addEventListener('mouseenter', function() {
                if (!this.classList.contains('active')) {
                    this.style.transform = 'translateX(5px)';
                }
            });
            
            step.addEventListener('mouseleave', function() {
                if (!this.classList.contains('active')) {
                    this.style.transform = 'translateX(0)';
                }
            });
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            // Redraw canvases on resize
            drawSCKM();
            drawMinPts();
            drawSTSCKM();
            drawTimeEvolution();
        });
    </script>
</body>
</html>
