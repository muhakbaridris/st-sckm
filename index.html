<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisasi Lengkap: DBSCAN, ST-DBSCAN, SCKM, ST-SCKM & Hybrid Models</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* Semua style CSS sebelumnya tetap sama */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        :root {
            --primary: #1a2980;
            --secondary: #26d0ce;
            --accent1: #FF6B6B;
            --accent2: #4ECDC4;
            --accent3: #FFD166;
            --accent4: #9B5DE5;
            --accent5: #00BBF9;
            --light: #f5f7fa;
            --dark: #2d3748;
            --gray: #718096;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            color: var(--dark);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        /* Header */
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 30px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            animation: fadeInDown 0.8s ease-out;
        }
        
        header::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.3;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            position: relative;
            z-index: 1;
        }
        
        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            max-width: 1000px;
            margin: 0 auto 20px;
            position: relative;
            z-index: 1;
        }
        
        .header-badges {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
            position: relative;
            z-index: 1;
        }
        
        .badge {
            background-color: rgba(255, 255, 255, 0.2);
            padding: 8px 20px;
            border-radius: 50px;
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Tab Container */
        .tab-container {
            display: flex;
            margin-bottom: 30px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            animation: fadeInUp 0.8s ease-out 0.2s both;
            flex-wrap: wrap;
        }
        
        .tabs {
            display: flex;
            flex-wrap: wrap;
            width: 100%;
        }
        
        .tab {
            flex: 1;
            min-width: 160px;
            padding: 18px 20px;
            background: none;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            color: var(--gray);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            position: relative;
        }
        
        .tab:hover {
            background-color: rgba(26, 41, 128, 0.05);
            color: var(--primary);
        }
        
        .tab.active {
            background-color: var(--primary);
            color: white;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 10px solid white;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
            padding: 40px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            margin-bottom: 40px;
            animation: fadeIn 0.5s ease-out;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Section Titles */
        .section-title {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            color: var(--primary);
            font-size: 1.8rem;
        }
        
        .section-title i {
            font-size: 2rem;
            color: var(--secondary);
        }
        
        /* Visualization Container */
        .visualization-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1200px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
        }
        
        /* Canvas Card */
        .canvas-card {
            background-color: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: transform 0.3s, box-shadow 0.3s;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .canvas-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--light);
        }
        
        .card-title {
            font-size: 1.5rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-title i {
            font-size: 1.5rem;
        }
        
        .card-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        /* Canvas */
        .canvas-container {
            position: relative;
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            background-color: #f9fafc;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 350px;
        }
        
        canvas {
            display: block;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.03);
            max-width: 100%;
            height: auto;
        }
        
        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: rgba(0, 0, 0, 0.02);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        /* Buttons */
        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary), #2a3a9e);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #15246d, var(--primary));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(26, 41, 128, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, var(--secondary), #2ce2e0);
            color: white;
        }
        
        .btn-secondary:hover {
            background: linear-gradient(135deg, #20b8b6, var(--secondary));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(38, 208, 206, 0.3);
        }
        
        .btn-accent {
            background: linear-gradient(135deg, var(--accent1), #ff8585);
            color: white;
        }
        
        .btn-accent:hover {
            background: linear-gradient(135deg, #ff5252, var(--accent1));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        
        .btn-outline {
            background-color: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
        }
        
        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Parameter Controls */
        .param-controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 25px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.02);
            border-radius: 10px;
        }
        
        .param-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .param-label {
            font-weight: 600;
            color: var(--primary);
            font-size: 0.95rem;
            display: flex;
            justify-content: space-between;
        }
        
        .param-value {
            font-weight: bold;
            color: var(--secondary);
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background-color: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }
        
        /* Formula Container */
        .formula-container {
            background: linear-gradient(135deg, #f0f7ff, #e6f3ff);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border-left: 5px solid var(--primary);
            position: relative;
            overflow: hidden;
        }
        
        .formula-container::before {
            content: "∑";
            position: absolute;
            top: -20px;
            right: 10px;
            font-size: 6rem;
            opacity: 0.05;
            color: var(--primary);
            font-weight: bold;
        }
        
        .formula-title {
            font-size: 1.4rem;
            color: var(--primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .formula {
            font-family: 'Courier New', monospace;
            font-size: 1.3rem;
            color: var(--dark);
            text-align: center;
            margin: 15px 0;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 30px;
            background-color: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .comparison-table th {
            background-color: var(--primary);
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f9fafc;
        }
        
        /* Algorithm Steps */
        .algorithm-steps-container {
            margin-top: 40px;
        }
        
        .algorithm-step {
            display: flex;
            align-items: flex-start;
            margin-bottom: 20px;
            padding: 25px;
            border-radius: 12px;
            background-color: rgba(0, 0, 0, 0.02);
            transition: transform 0.3s, background-color 0.3s;
            border-left: 5px solid transparent;
        }
        
        .algorithm-step:hover {
            transform: translateX(5px);
            background-color: rgba(26, 41, 128, 0.05);
        }
        
        .algorithm-step.active {
            border-left-color: var(--primary);
            background-color: rgba(26, 41, 128, 0.08);
        }
        
        .step-number {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            margin-right: 20px;
            flex-shrink: 0;
            box-shadow: 0 5px 15px rgba(26, 41, 128, 0.2);
        }
        
        .step-content {
            flex-grow: 1;
        }
        
        .step-content h4 {
            margin-bottom: 10px;
            color: var(--primary);
            font-size: 1.3rem;
        }
        
        /* Simulation Results */
        .simulation-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .result-card {
            padding: 25px;
            border-radius: 12px;
            background-color: white;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.06);
            transition: transform 0.3s;
        }
        
        .result-card:hover {
            transform: translateY(-5px);
        }
        
        .result-title {
            font-size: 1.3rem;
            color: var(--primary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .result-metrics {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px dashed #e2e8f0;
        }
        
        .metric-name {
            font-weight: 600;
            color: var(--dark);
        }
        
        .metric-value {
            font-weight: bold;
            color: var(--secondary);
        }
        
        /* About Section */
        .about-section {
            background: linear-gradient(135deg, var(--primary), #1a237e);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-top: 50px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .about-content {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .developer-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .developer-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--secondary), var(--accent2));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .developer-details {
            text-align: left;
        }
        
        .developer-name {
            font-size: 1.8rem;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .developer-title {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        
        .developer-links {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .developer-link {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .developer-link:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        /* Footer */
        footer {
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            color: var(--gray);
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeInDown {
            from { 
                opacity: 0;
                transform: translateY(-30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeInUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        /* Save Notification */
        .save-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            animation: fadeInUp 0.3s ease-out, fadeOut 0.3s ease-out 2.7s forwards;
        }
        
        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(20px); }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            
            .subtitle {
                font-size: 1.1rem;
            }
            
            .tab {
                min-width: 140px;
                padding: 15px;
                font-size: 0.9rem;
            }
            
            .visualization-container {
                grid-template-columns: 1fr;
            }
            
            .card-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            
            .card-actions {
                width: 100%;
                justify-content: center;
            }
            
            .formula {
                font-size: 1rem;
                padding: 15px;
            }
            
            .param-controls {
                grid-template-columns: 1fr;
            }
            
            .developer-info {
                flex-direction: column;
                text-align: center;
            }
            
            .developer-details {
                text-align: center;
            }
        }
        
        @media (max-width: 480px) {
            header {
                padding: 30px 20px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .tab {
                min-width: 120px;
                padding: 12px;
                font-size: 0.9rem;
            }
            
            .tab-content {
                padding: 25px 20px;
            }
            
            .btn {
                padding: 10px 18px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-project-diagram"></i> Visualisasi Lengkap Algoritma Klastering Spasial-Temporal</h1>
            <p class="subtitle">DBSCAN, ST-DBSCAN, SCKM, ST-SCKM, dan Model Hybrid untuk Analisis Data Kualitas Udara</p>
            
            <div class="header-badges">
                <div class="badge">
                    <i class="fas fa-save"></i> Save Gambar
                </div>
                <div class="badge">
                    <i class="fas fa-play-circle"></i> Visualisasi Interaktif
                </div>
                <div class="badge">
                    <i class="fas fa-chart-line"></i> 7 Metode
                </div>
                <div class="badge">
                    <i class="fas fa-sliders-h"></i> Kontrol Parameter
                </div>
            </div>
        </header>
        
        <div class="tab-container">
            <div class="tabs">
                <button class="tab active" data-tab="dbscan">
                    <i class="fas fa-dot-circle"></i> DBSCAN
                </button>
                <button class="tab" data-tab="st-dbscan">
                    <i class="fas fa-clock"></i> ST-DBSCAN
                </button>
                <button class="tab" data-tab="sckm">
                    <i class="fas fa-map-marked-alt"></i> SCKM
                </button>
                <button class="tab" data-tab="st-sckm">
                    <i class="fas fa-layer-group"></i> ST-SCKM
                </button>
                <button class="tab" data-tab="hybrid1">
                    <i class="fas fa-random"></i> Hybrid 1
                </button>
                <button class="tab" data-tab="hybrid2">
                    <i class="fas fa-exchange-alt"></i> Hybrid 2
                </button>
                <button class="tab" data-tab="simulation">
                    <i class="fas fa-chart-bar"></i> Simulasi
                </button>
                <button class="tab" data-tab="about">
                    <i class="fas fa-user"></i> About
                </button>
            </div>
        </div>
        
        <!-- Tab 1: DBSCAN -->
        <div id="dbscan" class="tab-content active">
            <div class="section-title">
                <i class="fas fa-dot-circle"></i>
                <h2>DBSCAN (Density-Based Spatial Clustering of Applications with Noise)</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">DBSCAN adalah algoritma klastering berbasis kepadatan yang dapat menemukan klaster dengan bentuk arbitrer dan mendeteksi noise. Tidak seperti K-Means, DBSCAN tidak memerlukan penentuan jumlah klaster di awal.</p>
            
            <div class="formula-container">
                <h3 class="formula-title"><i class="fas fa-calculator"></i> Konsep Utama DBSCAN</h3>
                <div class="formula">
                    Core Point: |N<sub>ε</sub>(p)| ≥ minPts<br>
                    Border Point: Titik dalam N<sub>ε</sub>(p) dari core point tetapi bukan core point<br>
                    Noise: Titik yang bukan core point maupun border point
                </div>
                <div class="formula" style="font-size: 1.1rem; margin-top: 10px;">
                    ε-neighborhood: N<sub>ε</sub>(p) = {q ∈ D | dist(p,q) ≤ ε}
                </div>
            </div>
            
            <div class="param-controls">
                <div class="param-group">
                    <div class="param-label">Parameter ε (eps): <span class="param-value" id="dbscan-eps-value">50</span></div>
                    <input type="range" id="dbscan-eps-slider" min="20" max="100" value="50" step="5">
                </div>
                <div class="param-group">
                    <div class="param-label">Parameter minPts: <span class="param-value" id="dbscan-minpts-value">5</span></div>
                    <input type="range" id="dbscan-minpts-slider" min="2" max="10" value="5" step="1">
                </div>
                <div class="param-group">
                    <div class="param-label">Jumlah Titik: <span class="param-value" id="dbscan-points-value">80</span></div>
                    <input type="range" id="dbscan-points-slider" min="30" max="150" value="80" step="10">
                </div>
            </div>
            
            <div class="visualization-container">
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-dot-circle"></i> Visualisasi DBSCAN</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-dbscan">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-dbscan">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="dbscan-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Klaster 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Klaster 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Klaster 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #9B5DE5;"></div>
                            <span>Noise</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #1A2980; border: 2px solid white;"></div>
                            <span>Core Point</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" id="run-dbscan">
                            <i class="fas fa-play"></i> Jalankan DBSCAN
                        </button>
                        <button class="btn btn-outline" id="step-dbscan">
                            <i class="fas fa-forward"></i> Langkah Berikutnya
                        </button>
                        <button class="btn btn-outline" id="prev-dbscan">
                            <i class="fas fa-backward"></i> Langkah Sebelumnya
                        </button>
                    </div>
                </div>
                
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-info-circle"></i> Konsep DBSCAN</h3>
                    </div>
                    
                    <div style="padding: 15px;">
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Core Points, Border Points, dan Noise</h4>
                            <p style="color: var(--dark); line-height: 1.6; margin-bottom: 10px;">
                                <strong>Core Point:</strong> Titik dengan setidaknya minPts titik dalam radius ε.
                            </p>
                            <p style="color: var(--dark); line-height: 1.6; margin-bottom: 10px;">
                                <strong>Border Point:</strong> Titik dalam ε-neighborhood dari core point tetapi bukan core point.
                            </p>
                            <p style="color: var(--dark); line-height: 1.6;">
                                <strong>Noise:</strong> Titik yang bukan core point maupun border point.
                            </p>
                        </div>
                        
                        <div style="background-color: rgba(255, 107, 107, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--accent1); margin-bottom: 10px;">Keunggulan DBSCAN</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• Tidak perlu tentukan jumlah klaster di awal</li>
                                <li style="padding: 5px 0;">• Dapat menemukan klaster bentuk arbitrer</li>
                                <li style="padding: 5px 0;">• Dapat mendeteksi noise/outlier</li>
                                <li style="padding: 5px 0;">• Robust terhadap outlier</li>
                            </ul>
                        </div>
                        
                        <div style="background-color: rgba(78, 205, 196, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--accent2); margin-bottom: 10px;">Keterbatasan DBSCAN</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• Sensitif terhadap parameter ε dan minPts</li>
                                <li style="padding: 5px 0;">• Kesulitan dengan kepadatan berbeda dalam dataset</li>
                                <li style="padding: 5px 0;">• Tidak mempertimbangkan dimensi waktu</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="algorithm-steps-container">
                <h3 class="section-title" style="margin-top: 50px;">
                    <i class="fas fa-list-ol"></i>
                    <span>Langkah-langkah Algoritma DBSCAN</span>
                </h3>
                
                <div class="algorithm-step active" id="dbscan-step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Identifikasi Core Points</h4>
                        <p>Untuk setiap titik p, hitung jumlah titik dalam radius ε. Jika jumlahnya ≥ minPts, maka p adalah core point.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="dbscan-step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Ekspansi Klaster</h4>
                        <p>Untuk setiap core point yang belum ditugaskan ke klaster, buat klaster baru dan tambahkan semua titik yang density-reachable dari core point tersebut.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="dbscan-step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Identifikasi Border Points</h4>
                        <p>Untuk setiap titik yang bukan core point tetapi berada dalam ε-neighborhood dari core point, tandai sebagai border point dan tambahkan ke klaster yang sesuai.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="dbscan-step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Identifikasi Noise</h4>
                        <p>Titik yang tidak ditugaskan ke klaster manapun ditandai sebagai noise (outlier).</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 2: ST-DBSCAN -->
        <div id="st-dbscan" class="tab-content">
            <div class="section-title">
                <i class="fas fa-clock"></i>
                <h2>ST-DBSCAN (Spatio-Temporal DBSCAN)</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">ST-DBSCAN adalah ekstensi dari DBSCAN yang memperhitungkan dimensi waktu. Algoritma ini cocok untuk data yang memiliki komponen spasial dan temporal, seperti data kualitas udara, lalu lintas, atau penyebaran penyakit.</p>
            
            <div class="formula-container">
                <h3 class="formula-title"><i class="fas fa-calculator"></i> Jarak Spasio-Temporal</h3>
                <div class="formula">
                    d<sub>gab</sub>((loc<sub>i</sub>,t<sub>i</sub>),(loc<sub>j</sub>,t<sub>j</sub>)) = √[(d<sub>spatial</sub>(loc<sub>i</sub>,loc<sub>j</sub>)/ε<sub>s</sub>)² + (d<sub>temporal</sub>(t<sub>i</sub>,t<sub>j</sub>)/ε<sub>t</sub>)²]
                </div>
                <div class="formula" style="font-size: 1.1rem; margin-top: 10px;">
                    Dua titik dianggap tetangga jika d<sub>spatial</sub> ≤ ε<sub>s</sub> DAN d<sub>temporal</sub> ≤ ε<sub>t</sub>
                </div>
            </div>
            
            <div class="param-controls">
                <div class="param-group">
                    <div class="param-label">ε<sub>spatial</sub>: <span class="param-value" id="st-dbscan-eps-s-value">50</span></div>
                    <input type="range" id="st-dbscan-eps-s-slider" min="20" max="100" value="50" step="5">
                </div>
                <div class="param-group">
                    <div class="param-label">ε<sub>temporal</sub>: <span class="param-value" id="st-dbscan-eps-t-value">2</span></div>
                    <input type="range" id="st-dbscan-eps-t-slider" min="1" max="5" value="2" step="0.5">
                </div>
                <div class="param-group">
                    <div class="param-label">minPts: <span class="param-value" id="st-dbscan-minpts-value">5</span></div>
                    <input type="range" id="st-dbscan-minpts-slider" min="2" max="10" value="5" step="1">
                </div>
                <div class="param-group">
                    <div class="param-label">Periode Waktu: <span class="param-value" id="st-dbscan-time-value">3</span></div>
                    <input type="range" id="st-dbscan-time-slider" min="2" max="5" value="3" step="1">
                </div>
            </div>
            
            <div class="visualization-container">
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-clock"></i> Visualisasi ST-DBSCAN (3D: Ruang + Waktu)</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-st-dbscan">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-st-dbscan">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="st-dbscan-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Klaster 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Klaster 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Klaster 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #9B5DE5;"></div>
                            <span>Noise</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #00BBF9;"></div>
                            <span>Periode Waktu</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" id="run-st-dbscan">
                            <i class="fas fa-play"></i> Jalankan ST-DBSCAN
                        </button>
                        <button class="btn btn-outline" id="step-st-dbscan">
                            <i class="fas fa-forward"></i> Langkah Berikutnya
                        </button>
                        <button class="btn btn-outline" id="prev-st-dbscan">
                            <i class="fas fa-backward"></i> Langkah Sebelumnya
                        </button>
                    </div>
                </div>
                
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-info-circle"></i> Konsep ST-DBSCAN</h3>
                    </div>
                    
                    <div style="padding: 15px;">
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Integrasi Dimensi Waktu</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                ST-DBSCAN memperluas konsep DBSCAN dengan menambahkan dimensi waktu. Dua titik dianggap tetangga jika keduanya dekat secara spasial <strong>dan</strong> temporal.
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Aplikasi dalam Data Kualitas Udara</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                ST-DBSCAN dapat mengidentifikasi episode polusi yang terjadi di lokasi tertentu pada waktu tertentu. Contoh: polusi tinggi di area industri pada jam sibuk.
                            </p>
                        </div>
                        
                        <div style="background-color: rgba(38, 208, 206, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--secondary); margin-bottom: 10px;">Keunggulan ST-DBSCAN</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• Mempertimbangkan dimensi waktu dan ruang</li>
                                <li style="padding: 5px 0;">• Dapat mendeteksi pola temporal</li>
                                <li style="padding: 5px 0;">• Cocok untuk data time-series spasial</li>
                                <li style="padding: 5px 0;">• Dapat mendeteksi noise dan outlier</li>
                            </ul>
                        </div>
                        
                        <div style="background-color: rgba(155, 93, 229, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: #9B5DE5; margin-bottom: 10px;">Parameter Tambahan</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• ε<sub>temporal</sub>: Radius temporal</li>
                                <li style="padding: 5px 0;">• d<sub>temporal</sub>: Fungsi jarak temporal</li>
                                <li style="padding: 5px 0;">• Unit waktu: jam, hari, minggu, dll.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="algorithm-steps-container">
                <h3 class="section-title" style="margin-top: 50px;">
                    <i class="fas fa-list-ol"></i>
                    <span>Langkah-langkah Algoritma ST-DBSCAN</span>
                </h3>
                
                <div class="algorithm-step active" id="st-dbscan-step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Definisi Jarak Spasio-Temporal</h4>
                        <p>Hitung jarak gabungan antara dua titik yang mencakup komponen spasial dan temporal menggunakan fungsi jarak yang sesuai.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-dbscan-step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Identifikasi Core Points Spasio-Temporal</h4>
                        <p>Titik dianggap core point jika memiliki setidaknya minPts titik dalam radius ε<sub>spatial</sub> dan ε<sub>temporal</sub>.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-dbscan-step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Ekspansi Klaster Spasio-Temporal</h4>
                        <p>Ekspansi klaster dilakukan dengan mempertimbangkan kedekatan spasial dan temporal secara simultan.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-dbscan-step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Identifikasi Border Points dan Noise</h4>
                        <p>Border points adalah titik dalam neighborhood spatio-temporal dari core point. Noise adalah titik yang tidak termasuk dalam klaster manapun.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 3: SCKM -->
        <div id="sckm" class="tab-content">
            <div class="section-title">
                <i class="fas fa-map-marked-alt"></i>
                <h2>SCKM (Spatially Constrained K-Means)</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">SCKM adalah modifikasi dari algoritma K-Means yang menambahkan batasan spasial. Tidak seperti DBSCAN, SCKM tidak menghasilkan noise karena semua titik dipaksa masuk ke dalam klaster.</p>
            
            <div class="formula-container">
                <h3 class="formula-title"><i class="fas fa-calculator"></i> Fungsi Objektif SCKM</h3>
                <div class="formula">
                    J = Σ<sub>i=1</sub><sup>n</sup> Σ<sub>j=1</sub><sup>k</sup> w<sub>ij</sub> ||x<sub>i</sub> - c<sub>j</sub>||² + λ Σ<sub>i=1</sub><sup>n</sup> Σ<sub>j=1</sub><sup>k</sup> φ<sub>ij</sub>
                </div>
                <div class="formula" style="font-size: 1.1rem; margin-top: 10px;">
                    λ: Parameter penyeimbang yang memaksa semua titik masuk ke klaster (tidak ada noise)
                </div>
            </div>
            
            <div class="param-controls">
                <div class="param-group">
                    <div class="param-label">Parameter λ: <span class="param-value" id="sckm-lambda-value">0.5</span></div>
                    <input type="range" id="sckm-lambda-slider" min="0" max="1" value="0.5" step="0.1">
                </div>
                <div class="param-group">
                    <div class="param-label">Jumlah Klaster (k): <span class="param-value" id="sckm-k-value">3</span></div>
                    <input type="range" id="sckm-k-slider" min="2" max="6" value="3" step="1">
                </div>
                <div class="param-group">
                    <div class="param-label">Jarak Spasial Maks (ε): <span class="param-value" id="sckm-epsilon-value">120</span></div>
                    <input type="range" id="sckm-epsilon-slider" min="50" max="200" value="120" step="10">
                </div>
            </div>
            
            <div class="visualization-container">
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-map-marked-alt"></i> Visualisasi SCKM (Tanpa Noise)</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-sckm">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-sckm">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="sckm-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Klaster 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Klaster 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Klaster 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #1A2980;"></div>
                            <span>Centroid</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #26d0ce; border: 1px dashed #26d0ce;"></div>
                            <span>Batasan Spasial</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" id="run-sckm">
                            <i class="fas fa-play"></i> Jalankan SCKM
                        </button>
                        <button class="btn btn-outline" id="step-sckm">
                            <i class="fas fa-forward"></i> Langkah Berikutnya
                        </button>
                        <button class="btn btn-outline" id="prev-sckm">
                            <i class="fas fa-backward"></i> Langkah Sebelumnya
                        </button>
                    </div>
                </div>
                
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-info-circle"></i> Konsep SCKM</h3>
                    </div>
                    
                    <div style="padding: 15px;">
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Perbedaan dengan K-Means Tradisional</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                SCKM menambahkan batasan spasial untuk memastikan klaster yang terbentuk kontigu secara geografis. Parameter λ memaksa semua titik masuk ke klaster (tidak ada noise).
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Aplikasi dalam Pemetaan Kualitas Udara</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                SCKM cocok untuk membagi wilayah geografis menjadi zona-zona dengan karakteristik kualitas udara yang serupa, dengan memastikan setiap zona merupakan area yang kontigu.
                            </p>
                        </div>
                        
                        <div style="background-color: rgba(255, 107, 107, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--accent1); margin-bottom: 10px;">Keunggulan SCKM</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• Menghasilkan klaster yang kontigu secara spasial</li>
                                <li style="padding: 5px 0;">• Tidak menghasilkan noise (semua titik masuk klaster)</li>
                                <li style="padding: 5px 0;">• Cocok untuk analisis berbasis wilayah</li>
                                <li style="padding: 5px 0;">• Interpretasi hasil yang mudah</li>
                            </ul>
                        </div>
                        
                        <div style="background-color: rgba(255, 209, 102, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--accent3); margin-bottom: 10px;">Keterbatasan SCKM</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• Perlu menentukan jumlah klaster di awal</li>
                                <li style="padding: 5px 0;">• Tidak mendeteksi outlier</li>
                                <li style="padding: 5px 0;">• Tidak mempertimbangkan dimensi waktu</li>
                                <li style="padding: 5px 0;">• Sensitif terhadap inisialisasi centroid</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="algorithm-steps-container">
                <h3 class="section-title" style="margin-top: 50px;">
                    <i class="fas fa-list-ol"></i>
                    <span>Langkah-langkah Algoritma SCKM</span>
                </h3>
                
                <div class="algorithm-step active" id="sckm-step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Inisialisasi Parameter</h4>
                        <p>Tentukan jumlah klaster (k), parameter λ, dan batasan spasial (ε). Parameter λ > 0 memastikan semua titik akan masuk ke klaster.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="sckm-step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Penempatan Awal Centroid</h4>
                        <p>Pilih posisi awal centroid secara acak atau dengan metode K-Means++ untuk hasil yang lebih baik.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="sckm-step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Penugasan Titik dengan Batasan Spasial</h4>
                        <p>Setiap titik ditugaskan ke centroid terdekat yang masih dalam batasan jarak spasial. Karena λ > 0, semua titik akan dipaksa masuk ke klaster.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="sckm-step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Perbarui Centroid dan Iterasi</h4>
                        <p>Hitung ulang posisi centroid berdasarkan titik-titik dalam klaster. Ulangi langkah 3-4 hingga konvergen.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 4: ST-SCKM -->
        <div id="st-sckm" class="tab-content">
            <div class="section-title">
                <i class="fas fa-layer-group"></i>
                <h2>ST-SCKM (Spatio-Temporal SCKM)</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">ST-SCKM memperluas konsep SCKM dengan menambahkan dimensi waktu dan regularisasi smoothness spasial. Algoritma ini cocok untuk data yang berubah seiring waktu seperti data sensor, lalu lintas, atau penyebaran penyakit.</p>
            
            <div class="formula-container">
                <h3 class="formula-title"><i class="fas fa-calculator"></i> Fungsi Objektif ST-SCKM</h3>
                <div class="formula">
                    J = Σ<sub>k=1</sub><sup>K</sup> Σ<sub>i∈C_k</sub> [w<sub>s</sub> ‖p<sub>i</sub> - μ<sub>k</sub><sup>(p)</sup>‖² + w<sub>t</sub> ‖z<sub>i</sub> - μ<sub>k</sub><sup>(z)</sup>‖²] + λ Σ<sub>k=1</sub><sup>K</sup> Σ<sub>i∈C_k</sub> Σ<sub>j∈Tetangga(i)</sub> I(l<sub>i</sub> ≠ l<sub>j</sub>)
                </div>
            </div>
            
            <div class="param-controls">
                <div class="param-group">
                    <div class="param-label">Bobot Spasial (w<sub>s</sub>): <span class="param-value" id="st-sckm-ws-value">0.7</span></div>
                    <input type="range" id="st-sckm-ws-slider" min="0" max="1" value="0.7" step="0.1">
                </div>
                <div class="param-group">
                    <div class="param-label">Bobot Temporal (w<sub>t</sub>): <span class="param-value" id="st-sckm-wt-value">0.3</span></div>
                    <input type="range" id="st-sckm-wt-slider" min="0" max="1" value="0.3" step="0.1">
                </div>
                <div class="param-group">
                    <div class="param-label">Regularisasi Smoothness (λ): <span class="param-value" id="st-sckm-lambda-value">0.5</span></div>
                    <input type="range" id="st-sckm-lambda-slider" min="0" max="1" value="0.5" step="0.1">
                </div>
                <div class="param-group">
                    <div class="param-label">Periode Waktu: <span class="param-value" id="st-sckm-time-value">3</span></div>
                    <input type="range" id="st-sckm-time-slider" min="2" max="5" value="3" step="1">
                </div>
            </div>
            
            <div class="visualization-container">
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-layer-group"></i> Visualisasi ST-SCKM (3D: Ruang + Waktu)</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-st-sckm">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-st-sckm">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="st-sckm-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Klaster 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Klaster 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Klaster 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #00BBF9;"></div>
                            <span>Periode Waktu</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #26d0ce; border: 1px dashed #26d0ce;"></div>
                            <span>Regularisasi Smoothness</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" id="run-st-sckm">
                            <i class="fas fa-play"></i> Jalankan ST-SCKM
                        </button>
                        <button class="btn btn-outline" id="step-st-sckm">
                            <i class="fas fa-forward"></i> Langkah Berikutnya
                        </button>
                        <button class="btn btn-outline" id="prev-st-sckm">
                            <i class="fas fa-backward"></i> Langkah Sebelumnya
                        </button>
                    </div>
                </div>
                
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-info-circle"></i> Konsep ST-SCKM</h3>
                    </div>
                    
                    <div style="padding: 15px;">
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Integrasi Dimensi Waktu</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                ST-SCKM memperluas SCKM dengan menambahkan dimensi waktu. Algoritma ini mempertimbangkan kemiripan spasial dan temporal secara simultan.
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Regularisasi Smoothness</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                Regularisasi smoothness meminimalkan perbedaan label antara titik-titik tetangga, menghasilkan klaster yang lebih homogen secara spasial.
                            </p>
                        </div>
                        
                        <div style="background-color: rgba(38, 208, 206, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--secondary); margin-bottom: 10px;">Keunggulan ST-SCKM</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• Mempertimbangkan dimensi ruang dan waktu</li>
                                <li style="padding: 5px 0;">• Menghasilkan klaster yang kontigu secara spasial</li>
                                <li style="padding: 5px 0;">• Regularisasi smoothness untuk homogenitas spasial</li>
                                <li style="padding: 5px 0;">• Cocok untuk data time-series spasial</li>
                            </ul>
                        </div>
                        
                        <div style="background-color: rgba(0, 187, 249, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: #00BBF9; margin-bottom: 10px;">Aplikasi dalam Data Kualitas Udara</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                ST-SCKM dapat mengidentifikasi pola polusi yang berubah seiring waktu di wilayah tertentu. Contoh: polusi tinggi di area industri pada musim tertentu.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="algorithm-steps-container">
                <h3 class="section-title" style="margin-top: 50px;">
                    <i class="fas fa-list-ol"></i>
                    <span>Langkah-langkah Algoritma ST-SCKM</span>
                </h3>
                
                <div class="algorithm-step active" id="st-sckm-step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Inisialisasi Multi-dimensi</h4>
                        <p>Tentukan parameter untuk setiap dimensi (spasial dan temporal). Inisialisasi centroid spasial dan temporal untuk setiap klaster.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-sckm-step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Penugasan dengan Bobot Spasial-Temporal</h4>
                        <p>Titik ditugaskan ke klaster berdasarkan kombinasi bobot spasial (w<sub>s</sub>) dan temporal (w<sub>t</sub>).</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-sckm-step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Pembaruan Centroid Multi-dimensi</h4>
                        <p>Centroid spasial dan temporal diperbarui secara terpisah berdasarkan titik-titik dalam klaster.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-sckm-step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Penerapan Regularisasi Smoothness</h4>
                        <p>Terapkan regularisasi smoothness (λ) untuk meminimalkan perbedaan label antara titik-titik tetangga.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="st-sckm-step-5">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h4>Iterasi hingga Konvergen</h4>
                        <p>Ulangi langkah 2-4 sampai konvergen (centroid tidak berubah) atau mencapai iterasi maksimum.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 5: Hybrid 1 (DBSCAN -> SCKM) -->
        <div id="hybrid1" class="tab-content">
            <div class="section-title">
                <i class="fas fa-random"></i>
                <h2>Hybrid Model 1: DBSCAN → SCKM</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">Model hybrid pertama menggabungkan DBSCAN dan SCKM secara sekuensial. DBSCAN digunakan terlebih dahulu untuk mendeteksi noise, kemudian SCKM diterapkan pada titik non-noise untuk membentuk klaster yang kontigu secara spasial.</p>
            
            <div class="formula-container">
                <h3 class="formula-title"><i class="fas fa-calculator"></i> Alur Hybrid Model 1</h3>
                <div class="formula">
                    Step 1: DBSCAN → Identifikasi noise dan klaster awal<br>
                    Step 2: SCKM → Terapkan pada titik non-noise untuk klaster kontigu
                </div>
            </div>
            
            <div class="param-controls">
                <div class="param-group">
                    <div class="param-label">DBSCAN ε: <span class="param-value" id="hybrid1-dbscan-eps-value">50</span></div>
                    <input type="range" id="hybrid1-dbscan-eps-slider" min="20" max="100" value="50" step="5">
                </div>
                <div class="param-group">
                    <div class="param-label">DBSCAN minPts: <span class="param-value" id="hybrid1-dbscan-minpts-value">5</span></div>
                    <input type="range" id="hybrid1-dbscan-minpts-slider" min="2" max="10" value="5" step="1">
                </div>
                <div class="param-group">
                    <div class="param-label">SCKM λ: <span class="param-value" id="hybrid1-sckm-lambda-value">0.5</span></div>
                    <input type="range" id="hybrid1-sckm-lambda-slider" min="0" max="1" value="0.5" step="0.1">
                </div>
                <div class="param-group">
                    <div class="param-label">SCKM k: <span class="param-value" id="hybrid1-sckm-k-value">3</span></div>
                    <input type="range" id="hybrid1-sckm-k-slider" min="2" max="6" value="3" step="1">
                </div>
            </div>
            
            <div class="visualization-container">
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-random"></i> Visualisasi Hybrid 1: DBSCAN → SCKM</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-hybrid1">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-hybrid1">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="hybrid1-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Klaster 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Klaster 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Klaster 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #9B5DE5;"></div>
                            <span>Noise (DBSCAN)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #1A2980;"></div>
                            <span>Centroid (SCKM)</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" id="run-hybrid1">
                            <i class="fas fa-play"></i> Jalankan Hybrid 1
                        </button>
                        <button class="btn btn-outline" id="step-hybrid1">
                            <i class="fas fa-forward"></i> Langkah Berikutnya
                        </button>
                        <button class="btn btn-outline" id="prev-hybrid1">
                            <i class="fas fa-backward"></i> Langkah Sebelumnya
                        </button>
                    </div>
                </div>
                
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-info-circle"></i> Konsep Hybrid Model 1</h3>
                    </div>
                    
                    <div style="padding: 15px;">
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Tahap 1: DBSCAN</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                DBSCAN digunakan untuk mengidentifikasi klaster awal berdasarkan kepadatan dan menyaring noise. Noise diidentifikasi dan dikeluarkan dari analisis lebih lanjut.
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Tahap 2: SCKM</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                SCKM diterapkan pada titik-titik non-noise untuk membentuk klaster yang kontigu secara spasial. Parameter λ memastikan semua titik non-noise masuk ke klaster.
                            </p>
                        </div>
                        
                        <div style="background-color: rgba(38, 208, 206, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--secondary); margin-bottom: 10px;">Keunggulan Hybrid 1</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• Menggabungkan keunggulan DBSCAN (deteksi noise) dan SCKM (klaster kontigu)</li>
                                <li style="padding: 5px 0;">• Noise disaring sebelum aplikasi SCKM</li>
                                <li style="padding: 5px 0;">• Hasil akhir: klaster kontigu tanpa noise</li>
                                <li style="padding: 5px 0;">• Cocok untuk data dengan noise dan kebutuhan kontiguitas spasial</li>
                            </ul>
                        </div>
                        
                        <div style="background-color: rgba(155, 93, 229, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: #9B5DE5; margin-bottom: 10px;">Aplikasi dalam Data Kualitas Udara</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                Hybrid 1 cocok untuk mengidentifikasi zona polusi yang kontigu sambil menyaring stasiun pengukuran yang menghasilkan data abnormal (noise).
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="algorithm-steps-container">
                <h3 class="section-title" style="margin-top: 50px;">
                    <i class="fas fa-list-ol"></i>
                    <span>Langkah-langkah Hybrid Model 1</span>
                </h3>
                
                <div class="algorithm-step active" id="hybrid1-step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Tahap 1: Aplikasi DBSCAN</h4>
                        <p>Terapkan DBSCAN pada dataset lengkap untuk mengidentifikasi klaster awal dan menyaring noise.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="hybrid1-step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Pemisahan Noise</h4>
                        <p>Pisahkan titik-titik yang diidentifikasi sebagai noise oleh DBSCAN dari titik-titik non-noise.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="hybrid1-step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Tahap 2: Aplikasi SCKM</h4>
                        <p>Terapkan SCKM pada titik-titik non-noise untuk membentuk klaster yang kontigu secara spasial.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="hybrid1-step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Integrasi Hasil</h4>
                        <p>Gabungkan hasil SCKM (klaster kontigu) dengan noise yang telah diidentifikasi oleh DBSCAN.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 6: Hybrid 2 (SCKM -> DBSCAN) -->
        <div id="hybrid2" class="tab-content">
            <div class="section-title">
                <i class="fas fa-exchange-alt"></i>
                <h2>Hybrid Model 2: SCKM → DBSCAN</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">Model hybrid kedua menerapkan SCKM terlebih dahulu untuk membentuk klaster kontigu, kemudian DBSCAN diterapkan dalam setiap klaster untuk mendeteksi sub-struktur dan noise internal.</p>
            
            <div class="formula-container">
                <h3 class="formula-title"><i class="fas fa-calculator"></i> Alur Hybrid Model 2</h3>
                <div class="formula">
                    Step 1: SCKM → Bentuk klaster kontigu<br>
                    Step 2: DBSCAN → Terapkan dalam setiap klaster untuk deteksi sub-struktur
                </div>
            </div>
            
            <div class="param-controls">
                <div class="param-group">
                    <div class="param-label">SCKM λ: <span class="param-value" id="hybrid2-sckm-lambda-value">0.5</span></div>
                    <input type="range" id="hybrid2-sckm-lambda-slider" min="0" max="1" value="0.5" step="0.1">
                </div>
                <div class="param-group">
                    <div class="param-label">SCKM k: <span class="param-value" id="hybrid2-sckm-k-value">3</span></div>
                    <input type="range" id="hybrid2-sckm-k-slider" min="2" max="6" value="3" step="1">
                </div>
                <div class="param-group">
                    <div class="param-label">DBSCAN ε: <span class="param-value" id="hybrid2-dbscan-eps-value">30</span></div>
                    <input type="range" id="hybrid2-dbscan-eps-slider" min="10" max="60" value="30" step="5">
                </div>
                <div class="param-group">
                    <div class="param-label">DBSCAN minPts: <span class="param-value" id="hybrid2-dbscan-minpts-value">3</span></div>
                    <input type="range" id="hybrid2-dbscan-minpts-slider" min="2" max="8" value="3" step="1">
                </div>
            </div>
            
            <div class="visualization-container">
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-exchange-alt"></i> Visualisasi Hybrid 2: SCKM → DBSCAN</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-hybrid2">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="reset-hybrid2">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="hybrid2-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Klaster SCKM 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Klaster SCKM 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Klaster SCKM 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #9B5DE5;"></div>
                            <span>Sub-klaster DBSCAN</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #1A2980;"></div>
                            <span>Noise Internal</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-secondary" id="run-hybrid2">
                            <i class="fas fa-play"></i> Jalankan Hybrid 2
                        </button>
                        <button class="btn btn-outline" id="step-hybrid2">
                            <i class="fas fa-forward"></i> Langkah Berikutnya
                        </button>
                        <button class="btn btn-outline" id="prev-hybrid2">
                            <i class="fas fa-backward"></i> Langkah Sebelumnya
                        </button>
                    </div>
                </div>
                
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-info-circle"></i> Konsep Hybrid Model 2</h3>
                    </div>
                    
                    <div style="padding: 15px;">
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Tahap 1: SCKM</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                SCKM digunakan untuk membagi wilayah menjadi klaster-klaster yang kontigu secara spasial. Semua titik masuk ke dalam klaster karena λ > 0.
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Tahap 2: DBSCAN</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                DBSCAN diterapkan secara terpisah dalam setiap klaster SCKM untuk mendeteksi sub-struktur berdasarkan kepadatan dan mengidentifikasi noise internal.
                            </p>
                        </div>
                        
                        <div style="background-color: rgba(38, 208, 206, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--secondary); margin-bottom: 10px;">Keunggulan Hybrid 2</h4>
                            <ul style="list-style-type: none; color: var(--dark);">
                                <li style="padding: 5px 0;">• Memastikan kontiguitas spasial sejak awal</li>
                                <li style="padding: 5px 0;">• Mendeteksi sub-struktur dalam klaster yang kontigu</li>
                                <li style="padding: 5px 0;">• Mengidentifikasi noise internal dalam klaster</li>
                                <li style="padding: 5px 0;">• Cocok untuk data dengan struktur hierarkis</li>
                            </ul>
                        </div>
                        
                        <div style="background-color: rgba(255, 209, 102, 0.05); padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: var(--accent3); margin-bottom: 10px;">Aplikasi dalam Data Kualitas Udara</h4>
                            <p style="color: var(--dark); line-height: 1.6;">
                                Hybrid 2 cocok untuk membagi wilayah menjadi zona polusi yang kontigu, lalu mengidentifikasi hotspot polusi (sub-klaster) dan stasiun pengukuran abnormal (noise internal) dalam setiap zona.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="algorithm-steps-container">
                <h3 class="section-title" style="margin-top: 50px;">
                    <i class="fas fa-list-ol"></i>
                    <span>Langkah-langkah Hybrid Model 2</span>
                </h3>
                
                <div class="algorithm-step active" id="hybrid2-step-1">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Tahap 1: Aplikasi SCKM</h4>
                        <p>Terapkan SCKM pada dataset lengkap untuk membentuk klaster-klaster yang kontigu secara spasial. Semua titik akan masuk ke dalam klaster.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="hybrid2-step-2">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Pemisahan Klaster SCKM</h4>
                        <p>Pisahkan dataset menjadi subset berdasarkan hasil klastering SCKM.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="hybrid2-step-3">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Tahap 2: Aplikasi DBSCAN dalam Klaster</h4>
                        <p>Terapkan DBSCAN secara terpisah dalam setiap klaster SCKM untuk mendeteksi sub-struktur dan noise internal.</p>
                    </div>
                </div>
                
                <div class="algorithm-step" id="hybrid2-step-4">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Integrasi Hasil</h4>
                        <p>Gabungkan hasil DBSCAN dari setiap klaster SCKM untuk mendapatkan pemahaman yang lebih detail tentang struktur data.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 7: Simulasi -->
        <div id="simulation" class="tab-content">
            <div class="section-title">
                <i class="fas fa-chart-bar"></i>
                <h2>Simulasi dan Perbandingan Metode</h2>
            </div>
            
            <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">Simulasi perbandingan kinerja semua metode (DBSCAN, ST-DBSCAN, SCKM, ST-SCKM, Hybrid 1, Hybrid 2) pada berbagai skenario data kualitas udara. Evaluasi menggunakan metrik Silhouette Score, Davies-Bouldin Index, dan Adjusted Rand Index.</p>
            
            <div class="param-controls">
                <div class="param-group">
                    <div class="param-label">Jenis Data: <span class="param-value" id="sim-data-type">Berklaster Baik</span></div>
                    <select id="sim-data-type-select" style="padding: 8px; border-radius: 6px; border: 1px solid #e2e8f0;">
                        <option value="well-clustered">Berklaster Baik</option>
                        <option value="noisy">Banyak Noise</option>
                        <option value="overlap">Overlap Antar Klaster</option>
                        <option value="varying-density">Kepadatan Berbeda</option>
                        <option value="temporal">Pola Temporal</option>
                    </select>
                </div>
                <div class="param-group">
                    <div class="param-label">Jumlah Titik: <span class="param-value" id="sim-points-value">200</span></div>
                    <input type="range" id="sim-points-slider" min="100" max="500" value="200" step="50">
                </div>
                <div class="param-group">
                    <div class="param-label">Proporsi Noise: <span class="param-value" id="sim-noise-value">10%</span></div>
                    <input type="range" id="sim-noise-slider" min="0" max="30" value="10" step="5">
                </div>
                <div class="param-group">
                    <div class="param-label">Jumlah Klaster Sebenarnya: <span class="param-value" id="sim-true-clusters-value">4</span></div>
                    <input type="range" id="sim-true-clusters-slider" min="2" max="6" value="4" step="1">
                </div>
            </div>
            
            <div class="visualization-container">
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-chart-bar"></i> Data Simulasi (Ground Truth)</h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" id="save-sim-data">
                                <i class="fas fa-camera"></i> Save Gambar
                            </button>
                            <button class="btn btn-outline" id="regenerate-sim">
                                <i class="fas fa-sync-alt"></i> Regenerasi Data
                            </button>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="sim-data-canvas" width="550" height="400"></canvas>
                    </div>
                    
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF6B6B;"></div>
                            <span>Klaster 1</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4ECDC4;"></div>
                            <span>Klaster 2</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFD166;"></div>
                            <span>Klaster 3</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #9B5DE5;"></div>
                            <span>Klaster 4</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #00BBF9;"></div>
                            <span>Noise</span>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button class="btn btn-accent" id="run-all-methods">
                            <i class="fas fa-play-circle"></i> Jalankan Semua Metode
                        </button>
                        <button class="btn btn-outline" id="step-simulation">
                            <i class="fas fa-forward"></i> Langkah Berikutnya
                        </button>
                    </div>
                </div>
                
                <div class="canvas-card">
                    <div class="card-header">
                        <h3 class="card-title"><i class="fas fa-chart-line"></i> Hasil Perbandingan Metode</h3>
                    </div>
                    
                    <div style="padding: 15px;">
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--primary); margin-bottom: 10px;">Metrik Evaluasi</h4>
                            <div class="result-metrics">
                                <div class="metric">
                                    <span class="metric-name">Silhouette Score</span>
                                    <span class="metric-value" id="silhouette-desc">(-1 sampai 1, semakin tinggi semakin baik)</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-name">Davies-Bouldin Index</span>
                                    <span class="metric-value" id="db-index-desc">(≥ 0, semakin rendah semakin baik)</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-name">Adjusted Rand Index</span>
                                    <span class="metric-value" id="ari-desc">(-1 sampai 1, semakin tinggi semakin baik)</span>
                                </div>
                                <div class="metric">
                                    <span class="metric-name">Waktu Eksekusi</span>
                                    <span class="metric-value" id="time-desc">(detik, semakin rendah semakin baik)</span>
                                </div>
                            </div>
                        </div>
                        
                        <div id="simulation-results" style="margin-top: 20px;">
                            <p style="color: var(--gray); text-align: center; padding: 20px;">
                                Klik "Jalankan Semua Metode" untuk melihat hasil perbandingan
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 40px;">
                <h3 class="section-title">
                    <i class="fas fa-table"></i>
                    <span>Ringkasan Hasil Simulasi</span>
                </h3>
                
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Metode</th>
                            <th>Silhouette</th>
                            <th>DB Index</th>
                            <th>ARI</th>
                            <th>Waktu (s)</th>
                            <th>Noise Terdeteksi</th>
                            <th>Kontiguitas</th>
                        </tr>
                    </thead>
                    <tbody id="simulation-summary">
                        <tr>
                            <td colspan="7" style="text-align: center; color: var(--gray); padding: 20px;">
                                Hasil simulasi akan muncul di sini setelah dijalankan
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="simulation-results" style="margin-top: 50px;">
                <div class="result-card">
                    <h4 class="result-title"><i class="fas fa-medal" style="color: gold;"></i> Performa Terbaik per Metrik</h4>
                    <div class="result-metrics">
                        <div class="metric">
                            <span class="metric-name">Silhouette Tertinggi</span>
                            <span class="metric-value" id="best-silhouette">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">DB Index Terendah</span>
                            <span class="metric-value" id="best-db">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">ARI Tertinggi</span>
                            <span class="metric-value" id="best-ari">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">Waktu Tercepat</span>
                            <span class="metric-value" id="best-time">-</span>
                        </div>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4 class="result-title"><i class="fas fa-lightbulb" style="color: var(--secondary);"></i> Rekomendasi Metode</h4>
                    <div style="margin-top: 15px;">
                        <p style="color: var(--dark); line-height: 1.6; margin-bottom: 10px;">
                            Berdasarkan karakteristik data:
                        </p>
                        <p id="method-recommendation" style="color: var(--primary); font-weight: 600; font-size: 1.1rem;">
                            -
                        </p>
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background-color: rgba(38, 208, 206, 0.05); border-radius: 8px;">
                        <p style="color: var(--dark); font-size: 0.9rem;">
                            <strong>Catatan:</strong> Rekomendasi didasarkan pada karakteristik data simulasi dan performa metode pada metrik evaluasi.
                        </p>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4 class="result-title"><i class="fas fa-chart-pie" style="color: var(--accent1);"></i> Statistik Data</h4>
                    <div class="result-metrics">
                        <div class="metric">
                            <span class="metric-name">Jumlah Titik</span>
                            <span class="metric-value" id="stat-points">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">Jumlah Klaster</span>
                            <span class="metric-value" id="stat-clusters">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">Proporsi Noise</span>
                            <span class="metric-value" id="stat-noise">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">Tingkat Overlap</span>
                            <span class="metric-value" id="stat-overlap">-</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- VISUALISASI HASIL KLASTER UNTUK SEMUA METODE -->
            <div style="margin-top: 50px;">
                <h3 class="section-title">
                    <i class="fas fa-chart-pie"></i>
                    <span>Visualisasi Hasil Klastering Semua Metode</span>
                </h3>
                
                <p style="margin-bottom: 25px; font-size: 1.1rem; color: var(--dark);">Visualisasi hasil klastering dari semua metode pada data simulasi yang sama. Bandingkan bagaimana setiap metode membentuk klaster dan mendeteksi noise.</p>
                
                <div class="visualization-container">
                    <!-- DBSCAN Result -->
                    <div class="canvas-card">
                        <div class="card-header">
                            <h3 class="card-title"><i class="fas fa-dot-circle"></i> DBSCAN</h3>
                            <div class="card-actions">
                                <button class="btn btn-outline save-method-img" data-canvas="sim-dbscan-canvas" data-filename="dbscan-result.png">
                                    <i class="fas fa-camera"></i> Save
                                </button>
                            </div>
                        </div>
                        <div class="canvas-container">
                            <canvas id="sim-dbscan-canvas" width="450" height="300"></canvas>
                        </div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FF6B6B;"></div>
                                <span>Klaster 1</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #4ECDC4;"></div>
                                <span>Klaster 2</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #9B5DE5;"></div>
                                <span>Noise</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; text-align: center;">
                            <span id="dbscan-cluster-count" style="font-size: 0.9rem; color: var(--gray);">Klaster: - | Noise: -</span>
                        </div>
                    </div>
                    
                    <!-- ST-DBSCAN Result -->
                    <div class="canvas-card">
                        <div class="card-header">
                            <h3 class="card-title"><i class="fas fa-clock"></i> ST-DBSCAN</h3>
                            <div class="card-actions">
                                <button class="btn btn-outline save-method-img" data-canvas="sim-stdbscan-canvas" data-filename="st-dbscan-result.png">
                                    <i class="fas fa-camera"></i> Save
                                </button>
                            </div>
                        </div>
                        <div class="canvas-container">
                            <canvas id="sim-stdbscan-canvas" width="450" height="300"></canvas>
                        </div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FF6B6B;"></div>
                                <span>Klaster 1</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #4ECDC4;"></div>
                                <span>Klaster 2</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FFD166;"></div>
                                <span>Klaster 3</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #9B5DE5;"></div>
                                <span>Noise</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; text-align: center;">
                            <span id="stdbscan-cluster-count" style="font-size: 0.9rem; color: var(--gray);">Klaster: - | Noise: -</span>
                        </div>
                    </div>
                    
                    <!-- SCKM Result -->
                    <div class="canvas-card">
                        <div class="card-header">
                            <h3 class="card-title"><i class="fas fa-map-marked-alt"></i> SCKM</h3>
                            <div class="card-actions">
                                <button class="btn btn-outline save-method-img" data-canvas="sim-sckm-canvas" data-filename="sckm-result.png">
                                    <i class="fas fa-camera"></i> Save
                                </button>
                            </div>
                        </div>
                        <div class="canvas-container">
                            <canvas id="sim-sckm-canvas" width="450" height="300"></canvas>
                        </div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FF6B6B;"></div>
                                <span>Klaster 1</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #4ECDC4;"></div>
                                <span>Klaster 2</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FFD166;"></div>
                                <span>Klaster 3</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #1A2980;"></div>
                                <span>Centroid</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; text-align: center;">
                            <span id="sckm-cluster-count" style="font-size: 0.9rem; color: var(--gray);">Klaster: 3 | Noise: 0</span>
                        </div>
                    </div>
                </div>
                
                <div class="visualization-container">
                    <!-- ST-SCKM Result -->
                    <div class="canvas-card">
                        <div class="card-header">
                            <h3 class="card-title"><i class="fas fa-layer-group"></i> ST-SCKM</h3>
                            <div class="card-actions">
                                <button class="btn btn-outline save-method-img" data-canvas="sim-stsckm-canvas" data-filename="st-sckm-result.png">
                                    <i class="fas fa-camera"></i> Save
                                </button>
                            </div>
                        </div>
                        <div class="canvas-container">
                            <canvas id="sim-stsckm-canvas" width="450" height="300"></canvas>
                        </div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FF6B6B;"></div>
                                <span>Klaster 1</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #4ECDC4;"></div>
                                <span>Klaster 2</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FFD166;"></div>
                                <span>Klaster 3</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #00BBF9;"></div>
                                <span>Waktu</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; text-align: center;">
                            <span id="stsckm-cluster-count" style="font-size: 0.9rem; color: var(--gray);">Klaster: 3 | Noise: 0</span>
                        </div>
                    </div>
                    
                    <!-- Hybrid 1 Result -->
                    <div class="canvas-card">
                        <div class="card-header">
                            <h3 class="card-title"><i class="fas fa-random"></i> Hybrid 1</h3>
                            <div class="card-actions">
                                <button class="btn btn-outline save-method-img" data-canvas="sim-hybrid1-canvas" data-filename="hybrid1-result.png">
                                    <i class="fas fa-camera"></i> Save
                                </button>
                            </div>
                        </div>
                        <div class="canvas-container">
                            <canvas id="sim-hybrid1-canvas" width="450" height="300"></canvas>
                        </div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FF6B6B;"></div>
                                <span>Klaster 1</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #4ECDC4;"></div>
                                <span>Klaster 2</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FFD166;"></div>
                                <span>Klaster 3</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #9B5DE5;"></div>
                                <span>Noise</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; text-align: center;">
                            <span id="hybrid1-cluster-count" style="font-size: 0.9rem; color: var(--gray);">Klaster: - | Noise: -</span>
                        </div>
                    </div>
                    
                    <!-- Hybrid 2 Result -->
                    <div class="canvas-card">
                        <div class="card-header">
                            <h3 class="card-title"><i class="fas fa-exchange-alt"></i> Hybrid 2</h3>
                            <div class="card-actions">
                                <button class="btn btn-outline save-method-img" data-canvas="sim-hybrid2-canvas" data-filename="hybrid2-result.png">
                                    <i class="fas fa-camera"></i> Save
                                </button>
                            </div>
                        </div>
                        <div class="canvas-container">
                            <canvas id="sim-hybrid2-canvas" width="450" height="300"></canvas>
                        </div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FF6B6B;"></div>
                                <span>Klaster 1</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #4ECDC4;"></div>
                                <span>Klaster 2</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #FFD166;"></div>
                                <span>Klaster 3</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background-color: #1A2980;"></div>
                                <span>Sub-klaster</span>
                            </div>
                        </div>
                        <div style="margin-top: 10px; text-align: center;">
                            <span id="hybrid2-cluster-count" style="font-size: 0.9rem; color: var(--gray);">Klaster: - | Sub-klaster: -</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 8: About -->
        <div id="about" class="tab-content">
            <div class="about-section">
                <div class="about-content">
                    <h2 style="font-size: 2.5rem; margin-bottom: 30px; color: white;">Tentang Pengembang</h2>
                    
                    <div class="developer-info">
                        <div class="developer-avatar">
                            <i class="fas fa-user-graduate"></i>
                        </div>
                        <div class="developer-details">
                            <h3 class="developer-name">Muh. Akbar Idris</h3>
                            <p class="developer-title">Mahasiswa Magister Statistika dan Sains Data</p>
                            <p style="font-size: 1.1rem; opacity: 0.9;">IPB University (Institut Pertanian Bogor)</p>
                        </div>
                    </div>
                    
                    <div style="margin-top: 30px; padding: 25px; background-color: rgba(255, 255, 255, 0.1); border-radius: 12px;">
                        <h4 style="font-size: 1.5rem; margin-bottom: 15px; color: white;">Tentang Aplikasi Ini</h4>
                        <p style="font-size: 1.1rem; line-height: 1.6; margin-bottom: 15px;">
                            Aplikasi visualisasi ini dikembangkan sebagai bagian dari penelitian dan pembelajaran tentang algoritma klastering spasial-temporal. 
                            Tujuannya adalah untuk memberikan pemahaman yang lebih baik tentang berbagai metode klastering dan aplikasinya dalam analisis data kualitas udara.
                        </p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">
                            Aplikasi ini menampilkan 7 metode klastering: DBSCAN, ST-DBSCAN, SCKM, ST-SCKM, dan dua model hybrid, dilengkapi dengan simulasi untuk membandingkan performa masing-masing metode.
                        </p>
                    </div>
                    
                    <div class="developer-links">
                        <a href="https://github.com/muhakbaridris" target="_blank" class="developer-link">
                            <i class="fab fa-github"></i> GitHub
                        </a>
                        <a href="https://www.linkedin.com/in/muh-akbar-idris" target="_blank" class="developer-link">
                            <i class="fab fa-linkedin"></i> LinkedIn
                        </a>
                        <a href="mailto:akbaridris@apps.ipb.ac.id" class="developer-link">
                            <i class="fas fa-envelope"></i> Email
                        </a>
                    </div>
                    
                    <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.2);">
                        <h4 style="font-size: 1.3rem; margin-bottom: 15px; color: white;">Teknologi yang Digunakan</h4>
                        <div style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                            <div style="padding: 10px 20px; background-color: rgba(255, 255, 255, 0.1); border-radius: 8px;">
                                <i class="fab fa-html5" style="color: #E34F26; margin-right: 8px;"></i> HTML5
                            </div>
                            <div style="padding: 10px 20px; background-color: rgba(255, 255, 255, 0.1); border-radius: 8px;">
                                <i class="fab fa-css3-alt" style="color: #1572B6; margin-right: 8px;"></i> CSS3
                            </div>
                            <div style="padding: 10px 20px; background-color: rgba(255, 255, 255, 0.1); border-radius: 8px;">
                                <i class="fab fa-js" style="color: #F7DF1E; margin-right: 8px;"></i> JavaScript
                            </div>
                            <div style="padding: 10px 20px; background-color: rgba(255, 255, 255, 0.1); border-radius: 8px;">
                                <i class="fas fa-chart-line" style="color: #26d0ce; margin-right: 8px;"></i> Canvas API
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 40px; text-align: center;">
                <h3 class="section-title">
                    <i class="fas fa-code"></i>
                    <span>Kode Sumber</span>
                </h3>
                <p style="font-size: 1.1rem; color: var(--dark); margin-bottom: 20px;">
                    Kode sumber lengkap dari aplikasi ini tersedia di repository GitHub:
                </p>
                <a href="https://github.com/muhakbaridris/spatial-temporal-clustering-visualization" target="_blank" class="btn btn-primary" style="font-size: 1.1rem; padding: 15px 30px;">
                    <i class="fab fa-github"></i> Lihat Kode Sumber di GitHub
                </a>
            </div>
        </div>
        
        <footer>
            <p style="font-size: 1.1rem; margin-bottom: 10px;">Visualisasi Lengkap Algoritma Klastering Spasial-Temporal</p>
            <p style="color: var(--gray);">DBSCAN • ST-DBSCAN • SCKM • ST-SCKM • Hybrid 1 (DBSCAN→SCKM) • Hybrid 2 (SCKM→DBSCAN) • Simulasi</p>
            <div style="margin-top: 20px; display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-save" style="color: var(--primary);"></i>
                    <span>Save Gambar</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-sliders-h" style="color: var(--secondary);"></i>
                    <span>Kontrol Parameter</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-chart-bar" style="color: var(--accent1);"></i>
                    <span>Simulasi & Perbandingan</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-random" style="color: #9B5DE5;"></i>
                    <span>Model Hybrid</span>
                </div>
            </div>
            
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(0,0,0,0.1);">
                <p style="margin-bottom: 5px;">Dikembangkan oleh: <strong>Muh. Akbar Idris</strong></p>
                <p style="margin-bottom: 5px; color: var(--gray);">Magister Statistika dan Sains Data, IPB University</p>
                <p>
                    <a href="https://github.com/muhakbaridris" target="_blank" style="color: var(--primary); text-decoration: none;">
                        <i class="fab fa-github"></i> GitHub: muhakbaridris
                    </a>
                </p>
            </div>
        </footer>
    </div>

    <script>
        // =============================================
        // PERBAIKAN UTAMA: SCKM dan ST-SCKM TANPA NOISE
        // =============================================
        
        // Tab switching functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and tab contents
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
                
                // Trigger resize for canvases
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, 100);
            });
        });
        
        // =============================================
        // DBSCAN Visualization
        // =============================================
        const dbscanCanvas = document.getElementById('dbscan-canvas');
        const dbscanCtx = dbscanCanvas.getContext('2d');
        let dbscanPoints = [];
        let dbscanClusters = [];
        let dbscanNoise = [];
        let dbscanStep = 0;
        let dbscanMaxSteps = 4;
        
        // Initialize DBSCAN visualization
        function initDBSCAN() {
            dbscanPoints = [];
            dbscanClusters = [];
            dbscanNoise = [];
            dbscanStep = 0;
            
            // Get parameters
            const eps = parseInt(document.getElementById('dbscan-eps-slider').value);
            const minPts = parseInt(document.getElementById('dbscan-minpts-slider').value);
            const numPoints = parseInt(document.getElementById('dbscan-points-slider').value);
            
            // Generate clusters
            const numClusters = 3;
            const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
            
            for (let c = 0; c < numClusters; c++) {
                const clusterCenterX = 150 + c * 200;
                const clusterCenterY = 150 + (c % 2 === 0 ? 50 : -50);
                
                // Generate points for this cluster
                const pointsInCluster = Math.floor(numPoints / numClusters);
                for (let i = 0; i < pointsInCluster; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 60 + 20;
                    
                    const x = clusterCenterX + Math.cos(angle) * distance;
                    const y = clusterCenterY + Math.sin(angle) * distance;
                    
                    // Add some noise points
                    let isNoise = false;
                    if (Math.random() < 0.1) {
                        // Create noise point
                        const noiseX = Math.random() * dbscanCanvas.width;
                        const noiseY = Math.random() * dbscanCanvas.height;
                        dbscanPoints.push({
                            x: noiseX,
                            y: noiseY,
                            cluster: -1,
                            isCore: false,
                            isBorder: false,
                            isNoise: true,
                            color: '#9B5DE5'
                        });
                        isNoise = true;
                    }
                    
                    if (!isNoise) {
                        dbscanPoints.push({
                            x: x,
                            y: y,
                            cluster: c,
                            isCore: false,
                            isBorder: false,
                            isNoise: false,
                            color: clusterColors[c]
                        });
                    }
                }
            }
            
            // Add some additional noise points
            const additionalNoise = Math.floor(numPoints * 0.05);
            for (let i = 0; i < additionalNoise; i++) {
                const x = Math.random() * dbscanCanvas.width;
                const y = Math.random() * dbscanCanvas.height;
                dbscanPoints.push({
                    x: x,
                    y: y,
                    cluster: -1,
                    isCore: false,
                    isBorder: false,
                    isNoise: true,
                    color: '#9B5DE5'
                });
            }
            
            drawDBSCAN();
            updateDBSCANAlgorithmSteps();
        }
        
        // Draw DBSCAN visualization
        function drawDBSCAN() {
            dbscanCtx.clearRect(0, 0, dbscanCanvas.width, dbscanCanvas.height);
            
            // Get parameters
            const eps = parseInt(document.getElementById('dbscan-eps-slider').value);
            
            // Draw ε-neighborhood circles for core points if step > 0
            if (dbscanStep >= 1) {
                dbscanPoints.forEach(point => {
                    if (point.isCore) {
                        dbscanCtx.beginPath();
                        dbscanCtx.arc(point.x, point.y, eps, 0, Math.PI * 2);
                        dbscanCtx.strokeStyle = 'rgba(26, 41, 128, 0.2)';
                        dbscanCtx.lineWidth = 2;
                        dbscanCtx.setLineDash([5, 5]);
                        dbscanCtx.stroke();
                        dbscanCtx.setLineDash([]);
                    }
                });
            }
            
            // Draw points
            dbscanPoints.forEach(point => {
                dbscanCtx.beginPath();
                dbscanCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                
                // Determine color based on step
                let color = point.color;
                if (dbscanStep >= 3) {
                    // In step 3, noise should be purple
                    color = point.isNoise ? '#9B5DE5' : point.color;
                } else if (dbscanStep >= 1) {
                    // In step 1 and 2, use cluster colors
                    color = point.color;
                }
                
                dbscanCtx.fillStyle = color;
                dbscanCtx.fill();
                
                // Draw border for core points
                if (point.isCore && dbscanStep >= 1) {
                    dbscanCtx.strokeStyle = '#1A2980';
                    dbscanCtx.lineWidth = 3;
                    dbscanCtx.stroke();
                } else if (point.isBorder && dbscanStep >= 3) {
                    dbscanCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    dbscanCtx.lineWidth = 1.5;
                    dbscanCtx.stroke();
                }
            });
            
            // Draw title and parameters
            dbscanCtx.fillStyle = '#2d3748';
            dbscanCtx.font = 'bold 16px Arial';
            dbscanCtx.fillText(`DBSCAN - ε=${eps}, minPts=${parseInt(document.getElementById('dbscan-minpts-slider').value)}`, 20, 30);
            
            // Draw step description
            const stepDescriptions = [
                'Langkah 1/4: Data awal dengan beberapa klaster dan noise',
                'Langkah 2/4: Identifikasi core points (titik dengan ≥ minPts dalam radius ε)',
                'Langkah 3/4: Ekspansi klaster dari core points',
                'Langkah 4/4: Identifikasi border points dan noise'
            ];
            
            if (dbscanStep < stepDescriptions.length) {
                dbscanCtx.fillStyle = '#718096';
                dbscanCtx.font = '14px Arial';
                dbscanCtx.fillText(stepDescriptions[dbscanStep], 20, 60);
            }
            
            // Draw cluster and noise counts
            const corePoints = dbscanPoints.filter(p => p.isCore).length;
            const borderPoints = dbscanPoints.filter(p => p.isBorder).length;
            const noisePoints = dbscanPoints.filter(p => p.isNoise).length;
            
            dbscanCtx.fillStyle = '#1a2980';
            dbscanCtx.font = 'bold 14px Arial';
            dbscanCtx.fillText(`Core: ${corePoints}, Border: ${borderPoints}, Noise: ${noisePoints}`, 20, 380);
        }
        
        // Step forward in DBSCAN algorithm
        function nextStepDBSCAN() {
            if (dbscanStep < dbscanMaxSteps) {
                dbscanStep++;
                
                // Execute step logic
                if (dbscanStep === 1) {
                    identifyCorePoints();
                } else if (dbscanStep === 2) {
                    expandClusters();
                } else if (dbscanStep === 3) {
                    identifyBorderAndNoise();
                } else if (dbscanStep === 4) {
                    // Final step - already done
                }
                
                drawDBSCAN();
                updateDBSCANAlgorithmSteps();
            }
        }
        
        // Step backward in DBSCAN algorithm
        function prevStepDBSCAN() {
            if (dbscanStep > 0) {
                dbscanStep--;
                
                // Reset points based on step
                if (dbscanStep === 0) {
                    // Reset all points to initial state
                    dbscanPoints.forEach(point => {
                        if (point.cluster >= 0) {
                            point.isCore = false;
                            point.isBorder = false;
                            point.isNoise = false;
                            point.color = point.cluster === 0 ? '#FF6B6B' : 
                                         point.cluster === 1 ? '#4ECDC4' : '#FFD166';
                        } else {
                            point.isCore = false;
                            point.isBorder = false;
                            point.isNoise = true;
                            point.color = '#9B5DE5';
                        }
                    });
                } else if (dbscanStep === 1) {
                    // Keep core points identified
                    identifyCorePoints();
                } else if (dbscanStep === 2) {
                    identifyCorePoints();
                    expandClusters();
                }
                
                drawDBSCAN();
                updateDBSCANAlgorithmSteps();
            }
        }
        
        // Identify core points
        function identifyCorePoints() {
            const eps = parseInt(document.getElementById('dbscan-eps-slider').value);
            const minPts = parseInt(document.getElementById('dbscan-minpts-slider').value);
            
            dbscanPoints.forEach(point => {
                // Count neighbors within ε radius
                let neighborCount = 0;
                dbscanPoints.forEach(otherPoint => {
                    if (point !== otherPoint) {
                        const dx = point.x - otherPoint.x;
                        const dy = point.y - otherPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= eps) {
                            neighborCount++;
                        }
                    }
                });
                
                // Mark as core point if neighborCount >= minPts
                if (neighborCount >= minPts && !point.isNoise) {
                    point.isCore = true;
                    point.color = point.cluster >= 0 ? 
                        (point.cluster === 0 ? '#FF6B6B' : point.cluster === 1 ? '#4ECDC4' : '#FFD166') : '#9B5DE5';
                } else {
                    point.isCore = false;
                }
            });
        }
        
        // Expand clusters from core points
        function expandClusters() {
            // Simple expansion - in real DBSCAN this would be more complex
            const eps = parseInt(document.getElementById('dbscan-eps-slider').value);
            
            dbscanPoints.forEach(point => {
                if (point.isCore && point.cluster >= 0) {
                    // "Expand" to nearby points
                    dbscanPoints.forEach(otherPoint => {
                        if (otherPoint !== point && !otherPoint.isCore && !otherPoint.isNoise && otherPoint.cluster === -1) {
                            const dx = point.x - otherPoint.x;
                            const dy = point.y - otherPoint.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance <= eps * 1.5) {
                                otherPoint.cluster = point.cluster;
                                otherPoint.color = point.cluster === 0 ? '#FF6B6B' : 
                                                  point.cluster === 1 ? '#4ECDC4' : '#FFD166';
                            }
                        }
                    });
                }
            });
        }
        
        // Identify border points and noise
        function identifyBorderAndNoise() {
            const eps = parseInt(document.getElementById('dbscan-eps-slider').value);
            
            dbscanPoints.forEach(point => {
                if (!point.isCore && point.cluster >= 0) {
                    // Check if point is within ε of any core point
                    let isBorder = false;
                    dbscanPoints.forEach(otherPoint => {
                        if (otherPoint.isCore && otherPoint.cluster === point.cluster) {
                            const dx = point.x - otherPoint.x;
                            const dy = point.y - otherPoint.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance <= eps) {
                                isBorder = true;
                            }
                        }
                    });
                    
                    if (isBorder) {
                        point.isBorder = true;
                    } else {
                        point.isNoise = true;
                        point.color = '#9B5DE5';
                    }
                } else if (!point.isCore && point.cluster < 0) {
                    point.isNoise = true;
                    point.color = '#9B5DE5';
                }
            });
        }
        
        // Update DBSCAN algorithm steps highlighting
        function updateDBSCANAlgorithmSteps() {
            // Reset all steps
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`dbscan-step-${i}`);
                if (stepEl) stepEl.classList.remove('active');
            }
            
            // Highlight current step
            if (dbscanStep >= 0 && dbscanStep < 4) {
                const currentStepEl = document.getElementById(`dbscan-step-${dbscanStep + 1}`);
                if (currentStepEl) currentStepEl.classList.add('active');
            }
        }
        
        // =============================================
        // ST-DBSCAN Visualization
        // =============================================
        const stDBSCANCanvas = document.getElementById('st-dbscan-canvas');
        const stDBSCANCtx = stDBSCANCanvas.getContext('2d');
        let stDBSCANPoints = [];
        let showTimeDimension = true;
        let stDBSCANStep = 0;
        let stDBSCANMaxSteps = 4;
        
        // Initialize ST-DBSCAN visualization
        function initSTDBSCAN() {
            stDBSCANPoints = [];
            stDBSCANStep = 0;
            
            // Get parameters
            const epsS = parseInt(document.getElementById('st-dbscan-eps-s-slider').value);
            const epsT = parseFloat(document.getElementById('st-dbscan-eps-t-slider').value);
            const minPts = parseInt(document.getElementById('st-dbscan-minpts-slider').value);
            const timePeriods = parseInt(document.getElementById('st-dbscan-time-slider').value);
            
            // Generate clusters across time
            const numClusters = 3;
            const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
            const timeColors = ['#00BBF9', '#0096D6', '#0077B3'];
            
            for (let t = 0; t < timePeriods; t++) {
                for (let c = 0; c < numClusters; c++) {
                    const clusterCenterX = 150 + c * 200;
                    const clusterCenterY = 150 + t * 80;
                    
                    // Generate points for this cluster at this time
                    const pointsInCluster = 8;
                    for (let i = 0; i < pointsInCluster; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 40 + 20;
                        
                        const x = clusterCenterX + Math.cos(angle) * distance;
                        const y = clusterCenterY + Math.sin(angle) * distance;
                        
                        stDBSCANPoints.push({
                            x: x,
                            y: y,
                            time: t,
                            cluster: c,
                            isNoise: false,
                            color: clusterColors[c],
                            timeColor: timeColors[t]
                        });
                    }
                }
                
                // Add some noise points at each time period
                const noisePoints = 5;
                for (let i = 0; i < noisePoints; i++) {
                    const x = Math.random() * stDBSCANCanvas.width;
                    const y = Math.random() * stDBSCANCanvas.height;
                    
                    stDBSCANPoints.push({
                        x: x,
                        y: y,
                        time: t,
                        cluster: -1,
                        isNoise: true,
                        color: '#9B5DE5',
                        timeColor: timeColors[t]
                    });
                }
            }
            
            drawSTDBSCAN();
            updateSTDBSCANAlgorithmSteps();
        }
        
        // Draw ST-DBSCAN visualization
        function drawSTDBSCAN() {
            stDBSCANCtx.clearRect(0, 0, stDBSCANCanvas.width, stDBSCANCanvas.height);
            
            // Get parameters
            const epsS = parseInt(document.getElementById('st-dbscan-eps-s-slider').value);
            const epsT = parseFloat(document.getElementById('st-dbscan-eps-t-slider').value);
            
            // Draw time dimension if enabled
            if (showTimeDimension) {
                // Draw time bands
                const timePeriods = parseInt(document.getElementById('st-dbscan-time-slider').value);
                const timeBandHeight = 80;
                
                for (let t = 0; t < timePeriods; t++) {
                    const y = 100 + t * timeBandHeight;
                    
                    stDBSCANCtx.fillStyle = `rgba(0, 187, 249, ${0.1 + t * 0.05})`;
                    stDBSCANCtx.fillRect(0, y - 30, stDBSCANCanvas.width, timeBandHeight);
                    
                    stDBSCANCtx.fillStyle = '#00BBF9';
                    stDBSCANCtx.font = 'bold 14px Arial';
                    stDBSCANCtx.fillText(`Waktu t=${t+1}`, 20, y - 10);
                }
            }
            
            // Draw points
            stDBSCANPoints.forEach(point => {
                // Adjust y position based on time if time dimension is shown
                const yPos = showTimeDimension ? point.y + point.time * 80 : point.y;
                
                stDBSCANCtx.beginPath();
                stDBSCANCtx.arc(point.x, yPos, 5, 0, Math.PI * 2);
                
                // Determine color based on step
                let color = point.color;
                if (stDBSCANStep >= 3) {
                    // In step 3, noise should be purple
                    color = point.isNoise ? '#9B5DE5' : point.color;
                }
                
                stDBSCANCtx.fillStyle = color;
                stDBSCANCtx.fill();
                
                // Add time indicator if time dimension is shown
                if (showTimeDimension) {
                    stDBSCANCtx.strokeStyle = point.timeColor;
                    stDBSCANCtx.lineWidth = 2;
                    stDBSCANCtx.stroke();
                }
            });
            
            // Draw title and parameters
            stDBSCANCtx.fillStyle = '#2d3748';
            stDBSCANCtx.font = 'bold 16px Arial';
            stDBSCANCtx.fillText(`ST-DBSCAN - εₛ=${epsS}, εₜ=${epsT}, minPts=${parseInt(document.getElementById('st-dbscan-minpts-slider').value)}`, 20, 30);
            
            // Draw step description
            const stepDescriptions = [
                'Langkah 1/4: Data awal dengan dimensi spasial dan temporal',
                'Langkah 2/4: Identifikasi core points berdasarkan ε_spatial dan ε_temporal',
                'Langkah 3/4: Ekspansi klaster dengan mempertimbangkan dimensi waktu',
                'Langkah 4/4: Hasil klaster spatio-temporal dengan noise'
            ];
            
            if (stDBSCANStep < stepDescriptions.length) {
                stDBSCANCtx.fillStyle = '#718096';
                stDBSCANCtx.font = '14px Arial';
                stDBSCANCtx.fillText(stepDescriptions[stDBSCANStep], 20, 60);
            }
            
            // Draw noise count
            const noiseCount = stDBSCANPoints.filter(p => p.isNoise).length;
            
            stDBSCANCtx.fillStyle = '#1a2980';
            stDBSCANCtx.font = 'bold 14px Arial';
            stDBSCANCtx.fillText(`Noise terdeteksi: ${noiseCount}`, 20, 380);
        }
        
        // Step forward in ST-DBSCAN algorithm
        function nextStepSTDBSCAN() {
            if (stDBSCANStep < stDBSCANMaxSteps) {
                stDBSCANStep++;
                
                // Mark some points as noise in later steps
                if (stDBSCANStep >= 3) {
                    stDBSCANPoints.forEach(point => {
                        if (point.cluster === -1 || Math.random() < 0.2) {
                            point.isNoise = true;
                            point.color = '#9B5DE5';
                        }
                    });
                }
                
                drawSTDBSCAN();
                updateSTDBSCANAlgorithmSteps();
            }
        }
        
        // Step backward in ST-DBSCAN algorithm
        function prevStepSTDBSCAN() {
            if (stDBSCANStep > 0) {
                stDBSCANStep--;
                
                // Reset points if going back to early steps
                if (stDBSCANStep < 3) {
                    const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
                    const timeColors = ['#00BBF9', '#0096D6', '#0077B3'];
                    const timePeriods = parseInt(document.getElementById('st-dbscan-time-slider').value);
                    
                    stDBSCANPoints.forEach(point => {
                        if (point.cluster >= 0) {
                            point.isNoise = false;
                            point.color = clusterColors[point.cluster];
                        } else {
                            point.isNoise = true;
                            point.color = '#9B5DE5';
                        }
                    });
                }
                
                drawSTDBSCAN();
                updateSTDBSCANAlgorithmSteps();
            }
        }
        
        // Update ST-DBSCAN algorithm steps highlighting
        function updateSTDBSCANAlgorithmSteps() {
            // Reset all steps
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`st-dbscan-step-${i}`);
                if (stepEl) stepEl.classList.remove('active');
            }
            
            // Highlight current step
            if (stDBSCANStep >= 0 && stDBSCANStep < 4) {
                const currentStepEl = document.getElementById(`st-dbscan-step-${stDBSCANStep + 1}`);
                if (currentStepEl) currentStepEl.classList.add('active');
            }
        }
        
        // =============================================
        // SCKM Visualization (TANPA NOISE)
        // =============================================
        const sckmCanvas = document.getElementById('sckm-canvas');
        const sckmCtx = sckmCanvas.getContext('2d');
        let sckmPoints = [];
        let sckmCentroids = [];
        let sckmStep = 0;
        let sckmMaxSteps = 4;
        
        // Initialize SCKM visualization
        function initSCKM() {
            sckmPoints = [];
            sckmCentroids = [];
            sckmStep = 0;
            
            // Update parameters from sliders
            const lambda = parseFloat(document.getElementById('sckm-lambda-slider').value);
            const k = parseInt(document.getElementById('sckm-k-slider').value);
            const epsilon = parseInt(document.getElementById('sckm-epsilon-slider').value);
            
            // Create centroids
            for (let i = 0; i < k; i++) {
                const angle = (i / k) * Math.PI * 2;
                const radius = 150;
                sckmCentroids.push({
                    x: 275 + Math.cos(angle) * radius,
                    y: 200 + Math.sin(angle) * radius,
                    color: '#1A2980',
                    clusterId: i
                });
            }
            
            // Generate points - NO NOISE POINTS
            for (let i = 0; i < 60; i++) {
                // Create points around centroids
                const clusterIdx = Math.floor(Math.random() * k);
                const centroid = sckmCentroids[clusterIdx];
                
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 80 + 20;
                
                const x = centroid.x + Math.cos(angle) * distance;
                const y = centroid.y + Math.sin(angle) * distance;
                
                // Color based on cluster
                const hue = (clusterIdx / k) * 360;
                const color = `hsl(${hue}, 70%, 60%)`;
                
                sckmPoints.push({
                    x: x,
                    y: y,
                    originalCluster: clusterIdx,
                    currentCluster: -1,
                    color: color
                });
            }
            
            drawSCKM();
            updateSCKMAlgorithmSteps();
        }
        
        // Draw SCKM visualization
        function drawSCKM() {
            sckmCtx.clearRect(0, 0, sckmCanvas.width, sckmCanvas.height);
            
            // Get parameters
            const epsilon = parseInt(document.getElementById('sckm-epsilon-slider').value);
            
            // Draw spatial constraints (circles around centroids)
            if (sckmStep >= 1) {
                sckmCentroids.forEach(centroid => {
                    sckmCtx.beginPath();
                    sckmCtx.arc(centroid.x, centroid.y, epsilon, 0, Math.PI * 2);
                    sckmCtx.strokeStyle = 'rgba(38, 208, 206, 0.3)';
                    sckmCtx.lineWidth = 2;
                    sckmCtx.setLineDash([5, 5]);
                    sckmCtx.stroke();
                    sckmCtx.setLineDash([]);
                });
            }
            
            // Draw points
            sckmPoints.forEach(point => {
                sckmCtx.beginPath();
                sckmCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                
                // Determine color based on step
                let color = point.color;
                if (sckmStep >= 2) {
                    // In step 2+, use cluster assignment
                    if (point.currentCluster >= 0) {
                        const hue = (point.currentCluster / sckmCentroids.length) * 360;
                        color = `hsl(${hue}, 70%, 60%)`;
                    }
                }
                
                sckmCtx.fillStyle = color;
                sckmCtx.fill();
            });
            
            // Draw centroids
            if (sckmStep >= 0) {
                sckmCentroids.forEach(centroid => {
                    sckmCtx.beginPath();
                    sckmCtx.arc(centroid.x, centroid.y, 10, 0, Math.PI * 2);
                    sckmCtx.fillStyle = centroid.color;
                    sckmCtx.fill();
                    
                    // Add glow effect
                    sckmCtx.shadowColor = centroid.color;
                    sckmCtx.shadowBlur = 15;
                    sckmCtx.fill();
                    sckmCtx.shadowBlur = 0;
                    
                    sckmCtx.strokeStyle = '#FFF';
                    sckmCtx.lineWidth = 2;
                    sckmCtx.stroke();
                    
                    // Draw cross inside centroid
                    sckmCtx.beginPath();
                    sckmCtx.moveTo(centroid.x - 5, centroid.y);
                    sckmCtx.lineTo(centroid.x + 5, centroid.y);
                    sckmCtx.moveTo(centroid.x, centroid.y - 5);
                    sckmCtx.lineTo(centroid.x, centroid.y + 5);
                    sckmCtx.strokeStyle = '#FFF';
                    sckmCtx.lineWidth = 2;
                    sckmCtx.stroke();
                });
            }
            
            // Draw lines from points to centroids if step > 1
            if (sckmStep >= 2) {
                sckmPoints.forEach(point => {
                    if (point.currentCluster >= 0) {
                        const centroid = sckmCentroids[point.currentCluster];
                        sckmCtx.beginPath();
                        sckmCtx.moveTo(point.x, point.y);
                        sckmCtx.lineTo(centroid.x, centroid.y);
                        sckmCtx.strokeStyle = 'rgba(26, 41, 128, 0.2)';
                        sckmCtx.lineWidth = 1;
                        sckmCtx.stroke();
                    }
                });
            }
            
            // Draw title and parameters
            const lambda = parseFloat(document.getElementById('sckm-lambda-slider').value);
            const k = parseInt(document.getElementById('sckm-k-slider').value);
            
            sckmCtx.fillStyle = '#2d3748';
            sckmCtx.font = 'bold 16px Arial';
            sckmCtx.fillText(`SCKM - k=${k}, λ=${lambda}, ε=${epsilon}`, 20, 30);
            
            // Draw step description
            const stepDescriptions = [
                'Langkah 1/4: Inisialisasi: Titik data dan centroid awal',
                'Langkah 2/4: Batasan Spasial: Area pengaruh setiap centroid (ε)',
                'Langkah 3/4: Penugasan: Semua titik masuk ke klaster (λ memaksa)',
                'Langkah 4/4: Pembaruan: Centroid diperbarui berdasarkan titik dalam klaster'
            ];
            
            if (sckmStep < stepDescriptions.length) {
                sckmCtx.fillStyle = '#718096';
                sckmCtx.font = '14px Arial';
                sckmCtx.fillText(stepDescriptions[sckmStep], 20, 60);
            }
            
            // Add note about no noise
            sckmCtx.fillStyle = '#FF6B6B';
            sckmCtx.font = 'bold 14px Arial';
            sckmCtx.fillText('CATATAN: SCKM tidak menghasilkan noise (semua titik masuk klaster)', 20, 380);
        }
        
        // Step forward in SCKM algorithm
        function nextStepSCKM() {
            if (sckmStep < sckmMaxSteps) {
                sckmStep++;
                
                // Execute step logic
                if (sckmStep === 1) {
                    // Step 1: Show centroids and spatial constraints
                    // Already handled in draw function
                } else if (sckmStep === 2) {
                    // Step 2: Assign points to nearest centroid
                    assignPointsToCentroids();
                } else if (sckmStep === 3) {
                    // Step 3: Update centroids
                    updateCentroids();
                } else if (sckmStep === 4) {
                    // Step 4: Final iteration
                    // Reassign points based on updated centroids
                    assignPointsToCentroids();
                    updateCentroids();
                }
                
                drawSCKM();
                updateSCKMAlgorithmSteps();
            }
        }
        
        // Step backward in SCKM algorithm
        function prevStepSCKM() {
            if (sckmStep > 0) {
                sckmStep--;
                
                // Reset points based on step
                if (sckmStep === 0) {
                    // Reset all points to original clusters
                    sckmPoints.forEach(point => {
                        point.currentCluster = -1;
                        const hue = (point.originalCluster / sckmCentroids.length) * 360;
                        point.color = `hsl(${hue}, 70%, 60%)`;
                    });
                } else if (sckmStep === 1) {
                    // Keep centroids but reset assignments
                    sckmPoints.forEach(point => {
                        point.currentCluster = -1;
                        const hue = (point.originalCluster / sckmCentroids.length) * 360;
                        point.color = `hsl(${hue}, 70%, 60%)`;
                    });
                } else if (sckmStep === 2) {
                    // Keep assignments but don't update centroids
                    assignPointsToCentroids();
                }
                
                drawSCKM();
                updateSCKMAlgorithmSteps();
            }
        }
        
        // Assign points to nearest centroid
        function assignPointsToCentroids() {
            sckmPoints.forEach(point => {
                let minDist = Infinity;
                let closestCentroid = -1;
                
                sckmCentroids.forEach((centroid, idx) => {
                    const dx = point.x - centroid.x;
                    const dy = point.y - centroid.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDist) {
                        minDist = distance;
                        closestCentroid = idx;
                    }
                });
                
                point.currentCluster = closestCentroid;
                const hue = (closestCentroid / sckmCentroids.length) * 360;
                point.color = `hsl(${hue}, 70%, 60%)`;
            });
        }
        
        // Update centroids
        function updateCentroids() {
            const k = sckmCentroids.length;
            const clusterSums = Array(k).fill().map(() => ({x: 0, y: 0, count: 0}));
            
            sckmPoints.forEach(point => {
                if (point.currentCluster >= 0) {
                    clusterSums[point.currentCluster].x += point.x;
                    clusterSums[point.currentCluster].y += point.y;
                    clusterSums[point.currentCluster].count++;
                }
            });
            
            clusterSums.forEach((sum, idx) => {
                if (sum.count > 0) {
                    sckmCentroids[idx].x = sum.x / sum.count;
                    sckmCentroids[idx].y = sum.y / sum.count;
                }
            });
        }
        
        // Update SCKM algorithm steps highlighting
        function updateSCKMAlgorithmSteps() {
            // Reset all steps
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`sckm-step-${i}`);
                if (stepEl) stepEl.classList.remove('active');
            }
            
            // Highlight current step
            if (sckmStep >= 0 && sckmStep < 4) {
                const currentStepEl = document.getElementById(`sckm-step-${sckmStep + 1}`);
                if (currentStepEl) currentStepEl.classList.add('active');
            }
        }
        
        // =============================================
        // ST-SCKM Visualization (TANPA NOISE)
        // =============================================
        const stSCKMCanvas = document.getElementById('st-sckm-canvas');
        const stSCKMCtx = stSCKMCanvas.getContext('2d');
        let stSCKMPoints = [];
        let stSCKMCentroids = [];
        let smoothnessActive = true;
        let stSCKMStep = 0;
        let stSCKMMaxSteps = 5;
        
        // Initialize ST-SCKM visualization
        function initSTSCKM() {
            stSCKMPoints = [];
            stSCKMCentroids = [];
            stSCKMStep = 0;
            
            // Update parameters from sliders
            const ws = parseFloat(document.getElementById('st-sckm-ws-slider').value);
            const wt = parseFloat(document.getElementById('st-sckm-wt-slider').value);
            const stLambda = parseFloat(document.getElementById('st-sckm-lambda-slider').value);
            const timePeriods = parseInt(document.getElementById('st-sckm-time-slider').value);
            
            // Create centroids for 3 clusters
            for (let i = 0; i < 3; i++) {
                const baseX = 150 + i * 150;
                const baseY = 150;
                const baseZ = i + 1; // Temporal dimension
                
                stSCKMCentroids.push({
                    x: baseX,
                    y: baseY,
                    z: baseZ,
                    color: '#1A2980',
                    clusterId: i
                });
            }
            
            // Generate points for each time period - NO NOISE
            for (let t = 1; t <= timePeriods; t++) {
                for (let i = 0; i < 3; i++) {
                    const centroid = stSCKMCentroids[i];
                    
                    for (let j = 0; j < 10; j++) {
                        // Points drift over time
                        const timeFactor = t * 0.3;
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 60 + 20;
                        
                        const baseX = centroid.x + (i === 1 ? 50 * timeFactor : 0);
                        const baseY = centroid.y + (i === 2 ? -30 * timeFactor : 0);
                        
                        const x = baseX + Math.cos(angle) * distance;
                        const y = baseY + Math.sin(angle) * distance;
                        const z = t; // Temporal value
                        
                        // Color based on cluster
                        let color;
                        if (i === 0) color = '#FF6B6B';
                        else if (i === 1) color = '#4ECDC4';
                        else color = '#FFD166';
                        
                        stSCKMPoints.push({
                            x: x,
                            y: y,
                            z: z,
                            time: t,
                            cluster: i,
                            color: color
                        });
                    }
                }
            }
            
            drawSTSCKM();
            updateSTSCKMAlgorithmSteps();
        }
        
        // Draw ST-SCKM visualization
        function drawSTSCKM() {
            stSCKMCtx.clearRect(0, 0, stSCKMCanvas.width, stSCKMCanvas.height);
            
            // Get parameters
            const ws = parseFloat(document.getElementById('st-sckm-ws-slider').value);
            const wt = parseFloat(document.getElementById('st-sckm-wt-slider').value);
            const stLambda = parseFloat(document.getElementById('st-sckm-lambda-slider').value);
            
            // Draw title and parameters
            stSCKMCtx.fillStyle = '#2d3748';
            stSCKMCtx.font = 'bold 16px Arial';
            stSCKMCtx.fillText(`ST-SCKM - wₛ=${ws}, wₜ=${wt}, λ=${stLambda}`, 20, 30);
            
            // Draw step description
            const stepDescriptions = [
                'Langkah 1/5: Inisialisasi: Data dengan dimensi spasial dan temporal',
                'Langkah 2/5: Centroid multi-dimensi dengan bobot spasial dan temporal',
                'Langkah 3/5: Penugasan titik dengan bobot wₛ dan wₜ',
                'Langkah 4/5: Penerapan regularisasi smoothness (λ)',
                'Langkah 5/5: Hasil klaster spatio-temporal tanpa noise'
            ];
            
            if (stSCKMStep < stepDescriptions.length) {
                stSCKMCtx.fillStyle = '#718096';
                stSCKMCtx.font = '14px Arial';
                stSCKMCtx.fillText(stepDescriptions[stSCKMStep], 20, 60);
            }
            
            // Draw 3D representation (projection)
            // We'll represent time (z) as vertical position
            const timeScale = 30; // Scale factor for time dimension
            
            // Draw points
            stSCKMPoints.forEach(point => {
                // Project 3D to 2D: x stays as x, y + z*timeScale for vertical position
                const projectedY = point.y + (point.z - 1) * timeScale;
                
                stSCKMCtx.beginPath();
                stSCKMCtx.arc(point.x, projectedY, 5, 0, Math.PI * 2);
                
                // Determine color based on step
                let color = point.color;
                if (stSCKMStep >= 3) {
                    // Apply smoothness effect in later steps
                    if (smoothnessActive && Math.random() < 0.3) {
                        // Lighten color for smoothness effect
                        color = stSCKMCtx.createLinearGradient(point.x-5, projectedY-5, point.x+5, projectedY+5);
                        color.addColorStop(0, point.color);
                        color.addColorStop(1, lightenColor(point.color, 30));
                    }
                }
                
                stSCKMCtx.fillStyle = color;
                stSCKMCtx.fill();
            });
            
            // Draw centroids with time dimension if step >= 1
            if (stSCKMStep >= 1) {
                stSCKMCentroids.forEach(centroid => {
                    const projectedY = centroid.y + (centroid.z - 1) * timeScale;
                    
                    // Draw centroid
                    stSCKMCtx.beginPath();
                    stSCKMCtx.arc(centroid.x, projectedY, 8, 0, Math.PI * 2);
                    stSCKMCtx.fillStyle = centroid.color;
                    stSCKMCtx.fill();
                    
                    // Add glow effect
                    stSCKMCtx.shadowColor = centroid.color;
                    stSCKMCtx.shadowBlur = 15;
                    stSCKMCtx.fill();
                    stSCKMCtx.shadowBlur = 0;
                    
                    // Draw cross inside centroid
                    stSCKMCtx.beginPath();
                    stSCKMCtx.moveTo(centroid.x - 4, projectedY);
                    stSCKMCtx.lineTo(centroid.x + 4, projectedY);
                    stSCKMCtx.moveTo(centroid.x, projectedY - 4);
                    stSCKMCtx.lineTo(centroid.x, projectedY + 4);
                    stSCKMCtx.strokeStyle = '#FFF';
                    stSCKMCtx.lineWidth = 1;
                    stSCKMCtx.stroke();
                    
                    // Draw temporal connection in step 2+
                    if (stSCKMStep >= 2 && centroid.clusterId === 0) {
                        // Draw line connecting centroids across time
                        const timePeriods = parseInt(document.getElementById('st-sckm-time-slider').value);
                        for (let t = 1; t < timePeriods; t++) {
                            const y1 = centroid.y + (t - 1) * timeScale;
                            const y2 = centroid.y + t * timeScale;
                            
                            stSCKMCtx.beginPath();
                            stSCKMCtx.moveTo(centroid.x, y1);
                            stSCKMCtx.lineTo(centroid.x, y2);
                            stSCKMCtx.strokeStyle = 'rgba(26, 41, 128, 0.3)';
                            stSCKMCtx.lineWidth = 2;
                            stSCKMCtx.setLineDash([5, 3]);
                            stSCKMCtx.stroke();
                            stSCKMCtx.setLineDash([]);
                        }
                    }
                });
            }
            
            // Draw time axis
            stSCKMCtx.strokeStyle = '#718096';
            stSCKMCtx.lineWidth = 1;
            stSCKMCtx.beginPath();
            stSCKMCtx.moveTo(50, 50);
            stSCKMCtx.lineTo(50, 350);
            stSCKMCtx.stroke();
            
            // Draw time labels
            const timePeriods = parseInt(document.getElementById('st-sckm-time-slider').value);
            for (let t = 1; t <= timePeriods; t++) {
                const y = 50 + (t - 1) * timeScale * 2;
                stSCKMCtx.fillStyle = '#2d3748';
                stSCKMCtx.font = '14px Arial';
                stSCKMCtx.fillText(`t=${t}`, 30, y + 5);
                
                // Draw time marker
                stSCKMCtx.beginPath();
                stSCKMCtx.moveTo(45, y);
                stSCKMCtx.lineTo(55, y);
                stSCKMCtx.strokeStyle = '#718096';
                stSCKMCtx.lineWidth = 2;
                stSCKMCtx.stroke();
            }
            
            // Add note about no noise
            stSCKMCtx.fillStyle = '#FF6B6B';
            stSCKMCtx.font = 'bold 14px Arial';
            stSCKMCtx.fillText('CATATAN: ST-SCKM tidak menghasilkan noise (semua titik masuk klaster)', 20, 380);
        }
        
        // Helper function to lighten a color
        function lightenColor(color, percent) {
            // Simple color lightening - in a real implementation, use a proper color library
            return color;
        }
        
        // Step forward in ST-SCKM algorithm
        function nextStepSTSCKM() {
            if (stSCKMStep < stSCKMMaxSteps) {
                stSCKMStep++;
                drawSTSCKM();
                updateSTSCKMAlgorithmSteps();
            }
        }
        
        // Step backward in ST-SCKM algorithm
        function prevStepSTSCKM() {
            if (stSCKMStep > 0) {
                stSCKMStep--;
                drawSTSCKM();
                updateSTSCKMAlgorithmSteps();
            }
        }
        
        // Update ST-SCKM algorithm steps highlighting
        function updateSTSCKMAlgorithmSteps() {
            // Reset all steps
            for (let i = 1; i <= 5; i++) {
                const stepEl = document.getElementById(`st-sckm-step-${i}`);
                if (stepEl) stepEl.classList.remove('active');
            }
            
            // Highlight current step
            if (stSCKMStep >= 0 && stSCKMStep < 5) {
                const currentStepEl = document.getElementById(`st-sckm-step-${stSCKMStep + 1}`);
                if (currentStepEl) currentStepEl.classList.add('active');
            }
        }
        
        // =============================================
        // Hybrid 1 Visualization (DBSCAN -> SCKM)
        // =============================================
        const hybrid1Canvas = document.getElementById('hybrid1-canvas');
        const hybrid1Ctx = hybrid1Canvas.getContext('2d');
        let hybrid1Points = [];
        let hybrid1Step = 0;
        let hybrid1MaxSteps = 4;
        
        // Initialize Hybrid 1 visualization
        function initHybrid1() {
            hybrid1Points = [];
            hybrid1Step = 0;
            
            // Generate data with clusters and noise
            const numClusters = 3;
            const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
            
            for (let c = 0; c < numClusters; c++) {
                const clusterCenterX = 150 + c * 200;
                const clusterCenterY = 150 + (c % 2 === 0 ? 50 : -50);
                
                // Generate points for this cluster
                const pointsInCluster = 15;
                for (let i = 0; i < pointsInCluster; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 60 + 20;
                    
                    const x = clusterCenterX + Math.cos(angle) * distance;
                    const y = clusterCenterY + Math.sin(angle) * distance;
                    
                    hybrid1Points.push({
                        x: x,
                        y: y,
                        cluster: c,
                        isNoise: false,
                        color: clusterColors[c],
                        dbscanCluster: -1,
                        sckmCluster: -1
                    });
                }
            }
            
            // Add noise points
            const noisePoints = 10;
            for (let i = 0; i < noisePoints; i++) {
                const x = Math.random() * hybrid1Canvas.width;
                const y = Math.random() * hybrid1Canvas.height;
                
                hybrid1Points.push({
                    x: x,
                    y: y,
                    cluster: -1,
                    isNoise: true,
                    color: '#9B5DE5',
                    dbscanCluster: -1,
                    sckmCluster: -1
                });
            }
            
            drawHybrid1();
            updateHybrid1AlgorithmSteps();
        }
        
        // Draw Hybrid 1 visualization
        function drawHybrid1() {
            hybrid1Ctx.clearRect(0, 0, hybrid1Canvas.width, hybrid1Canvas.height);
            
            // Draw points
            hybrid1Points.forEach(point => {
                hybrid1Ctx.beginPath();
                hybrid1Ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                
                // Determine color based on step
                let color = point.color;
                if (hybrid1Step === 1) {
                    // Step 1: DBSCAN identifies noise
                    color = point.isNoise ? '#9B5DE5' : point.color;
                } else if (hybrid1Step === 2) {
                    // Step 2: SCKM applied to non-noise points
                    color = point.isNoise ? '#9B5DE5' : 
                            (point.sckmCluster === 0 ? '#FF6B6B' : 
                             point.sckmCluster === 1 ? '#4ECDC4' : '#FFD166');
                } else if (hybrid1Step >= 3) {
                    // Final result
                    color = point.isNoise ? '#9B5DE5' : 
                            (point.sckmCluster === 0 ? '#FF6B6B' : 
                             point.sckmCluster === 1 ? '#4ECDC4' : '#FFD166');
                }
                
                hybrid1Ctx.fillStyle = color;
                hybrid1Ctx.fill();
            });
            
            // Draw SCKM centroids in steps 2+
            if (hybrid1Step >= 2) {
                // Draw SCKM centroids
                const k = parseInt(document.getElementById('hybrid1-sckm-k-slider').value);
                for (let i = 0; i < k; i++) {
                    const angle = (i / k) * Math.PI * 2;
                    const radius = 150;
                    const centroidX = 275 + Math.cos(angle) * radius;
                    const centroidY = 200 + Math.sin(angle) * radius;
                    
                    hybrid1Ctx.beginPath();
                    hybrid1Ctx.arc(centroidX, centroidY, 10, 0, Math.PI * 2);
                    hybrid1Ctx.fillStyle = '#1A2980';
                    hybrid1Ctx.fill();
                    
                    hybrid1Ctx.strokeStyle = '#FFF';
                    hybrid1Ctx.lineWidth = 2;
                    hybrid1Ctx.stroke();
                    
                    // Draw cross inside centroid
                    hybrid1Ctx.beginPath();
                    hybrid1Ctx.moveTo(centroidX - 5, centroidY);
                    hybrid1Ctx.lineTo(centroidX + 5, centroidY);
                    hybrid1Ctx.moveTo(centroidX, centroidY - 5);
                    hybrid1Ctx.lineTo(centroidX, centroidY + 5);
                    hybrid1Ctx.strokeStyle = '#FFF';
                    hybrid1Ctx.lineWidth = 2;
                    hybrid1Ctx.stroke();
                }
            }
            
            // Draw title and step description
            hybrid1Ctx.fillStyle = '#2d3748';
            hybrid1Ctx.font = 'bold 16px Arial';
            hybrid1Ctx.fillText('Hybrid 1: DBSCAN → SCKM', 20, 30);
            
            const stepDescriptions = [
                'Langkah 1/4: Data awal dengan klaster dan noise',
                'Langkah 2/4: DBSCAN: Identifikasi noise (warna ungu)',
                'Langkah 3/4: SCKM: Terapkan pada titik non-noise untuk klaster kontigu',
                'Langkah 4/4: Hasil akhir: Klaster kontigu + noise terpisah'
            ];
            
            if (hybrid1Step < stepDescriptions.length) {
                hybrid1Ctx.fillStyle = '#718096';
                hybrid1Ctx.font = '14px Arial';
                hybrid1Ctx.fillText(stepDescriptions[hybrid1Step], 20, 60);
            }
            
            // Draw statistics
            const noiseCount = hybrid1Points.filter(p => p.isNoise).length;
            const clusterCount = hybrid1Points.filter(p => !p.isNoise).length;
            
            hybrid1Ctx.fillStyle = '#1a2980';
            hybrid1Ctx.font = 'bold 14px Arial';
            hybrid1Ctx.fillText(`Titik non-noise: ${clusterCount}, Noise: ${noiseCount}`, 20, 380);
        }
        
        // Step forward in Hybrid 1 algorithm
        function nextStepHybrid1() {
            if (hybrid1Step < hybrid1MaxSteps) {
                hybrid1Step++;
                
                // Execute step logic
                if (hybrid1Step === 1) {
                    // DBSCAN identifies noise
                    hybrid1Points.forEach(point => {
                        if (point.cluster === -1 || Math.random() < 0.2) {
                            point.isNoise = true;
                            point.color = '#9B5DE5';
                        }
                    });
                } else if (hybrid1Step === 2) {
                    // SCKM applied to non-noise points
                    hybrid1Points.forEach(point => {
                        if (!point.isNoise) {
                            // Assign to SCKM clusters
                            const clusterIdx = Math.floor(Math.random() * 3);
                            point.sckmCluster = clusterIdx;
                        }
                    });
                }
                
                drawHybrid1();
                updateHybrid1AlgorithmSteps();
            }
        }
        
        // Step backward in Hybrid 1 algorithm
        function prevStepHybrid1() {
            if (hybrid1Step > 0) {
                hybrid1Step--;
                
                // Reset points based on step
                if (hybrid1Step === 0) {
                    // Reset to initial state
                    const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
                    hybrid1Points.forEach(point => {
                        if (point.cluster >= 0) {
                            point.isNoise = false;
                            point.color = clusterColors[point.cluster];
                            point.sckmCluster = -1;
                        } else {
                            point.isNoise = true;
                            point.color = '#9B5DE5';
                            point.sckmCluster = -1;
                        }
                    });
                } else if (hybrid1Step === 1) {
                    // Keep DBSCAN noise identification
                    hybrid1Points.forEach(point => {
                        if (point.cluster === -1 || Math.random() < 0.2) {
                            point.isNoise = true;
                            point.color = '#9B5DE5';
                        } else {
                            point.isNoise = false;
                            point.color = point.cluster === 0 ? '#FF6B6B' : 
                                         point.cluster === 1 ? '#4ECDC4' : '#FFD166';
                            point.sckmCluster = -1;
                        }
                    });
                }
                
                drawHybrid1();
                updateHybrid1AlgorithmSteps();
            }
        }
        
        // Update Hybrid 1 algorithm steps highlighting
        function updateHybrid1AlgorithmSteps() {
            // Reset all steps
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`hybrid1-step-${i}`);
                if (stepEl) stepEl.classList.remove('active');
            }
            
            // Highlight current step
            if (hybrid1Step >= 0 && hybrid1Step < 4) {
                const currentStepEl = document.getElementById(`hybrid1-step-${hybrid1Step + 1}`);
                if (currentStepEl) currentStepEl.classList.add('active');
            }
        }
        
        // =============================================
        // Hybrid 2 Visualization (SCKM -> DBSCAN)
        // =============================================
        const hybrid2Canvas = document.getElementById('hybrid2-canvas');
        const hybrid2Ctx = hybrid2Canvas.getContext('2d');
        let hybrid2Points = [];
        let hybrid2Step = 0;
        let hybrid2MaxSteps = 4;
        
        // Initialize Hybrid 2 visualization
        function initHybrid2() {
            hybrid2Points = [];
            hybrid2Step = 0;
            
            // Generate data organized into contiguous clusters
            const numClusters = 3;
            const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
            
            for (let c = 0; c < numClusters; c++) {
                const clusterCenterX = 150 + c * 200;
                const clusterCenterY = 150 + (c % 2 === 0 ? 50 : -50);
                
                // Generate points for this cluster (contiguous)
                const pointsInCluster = 20;
                for (let i = 0; i < pointsInCluster; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 80 + 20;
                    
                    const x = clusterCenterX + Math.cos(angle) * distance;
                    const y = clusterCenterY + Math.sin(angle) * distance;
                    
                    hybrid2Points.push({
                        x: x,
                        y: y,
                        sckmCluster: c,
                        dbscanSubcluster: -1,
                        isInternalNoise: false,
                        color: clusterColors[c]
                    });
                }
            }
            
            drawHybrid2();
            updateHybrid2AlgorithmSteps();
        }
        
        // Draw Hybrid 2 visualization
        function drawHybrid2() {
            hybrid2Ctx.clearRect(0, 0, hybrid2Canvas.width, hybrid2Canvas.height);
            
            // Draw points
            hybrid2Points.forEach(point => {
                hybrid2Ctx.beginPath();
                hybrid2Ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                
                // Determine color based on step
                let color = point.color;
                if (hybrid2Step === 1) {
                    // Step 1: SCKM clusters
                    color = point.color;
                } else if (hybrid2Step >= 2) {
                    // Step 2+: DBSCAN within clusters
                    if (point.isInternalNoise) {
                        color = '#1A2980'; // Internal noise
                    } else if (point.dbscanSubcluster >= 0) {
                        // Subcluster - use different shade
                        const baseColor = point.sckmCluster === 0 ? '#FF6B6B' : 
                                         point.sckmCluster === 1 ? '#4ECDC4' : '#FFD166';
                        // Darken for subcluster 1, lighten for subcluster 2
                        color = point.dbscanSubcluster === 0 ? baseColor : 
                               point.dbscanSubcluster === 1 ? 
                               (point.sckmCluster === 0 ? '#FF8585' : 
                                point.sckmCluster === 1 ? '#6ED9D1' : '#FFDF8A') : 
                               (point.sckmCluster === 0 ? '#E65252' : 
                                point.sckmCluster === 1 ? '#3ABBB3' : '#E6BF67');
                    }
                }
                
                hybrid2Ctx.fillStyle = color;
                hybrid2Ctx.fill();
                
                // Add border for internal noise in step 2 and 3
                if ((hybrid2Step >= 2) && point.isInternalNoise) {
                    hybrid2Ctx.strokeStyle = '#FFF';
                    hybrid2Ctx.lineWidth = 2;
                    hybrid2Ctx.stroke();
                }
            });
            
            // Draw SCKM cluster boundaries in step 1
            if (hybrid2Step === 1) {
                hybrid2Ctx.strokeStyle = 'rgba(26, 41, 128, 0.3)';
                hybrid2Ctx.lineWidth = 2;
                hybrid2Ctx.setLineDash([5, 5]);
                
                // Draw approximate boundaries around SCKM clusters
                hybrid2Ctx.beginPath();
                hybrid2Ctx.arc(150, 150, 100, 0, Math.PI * 2);
                hybrid2Ctx.stroke();
                
                hybrid2Ctx.beginPath();
                hybrid2Ctx.arc(350, 100, 100, 0, Math.PI * 2);
                hybrid2Ctx.stroke();
                
                hybrid2Ctx.beginPath();
                hybrid2Ctx.arc(550, 150, 100, 0, Math.PI * 2);
                hybrid2Ctx.stroke();
                
                hybrid2Ctx.setLineDash([]);
            }
            
            // Draw title and step description
            hybrid2Ctx.fillStyle = '#2d3748';
            hybrid2Ctx.font = 'bold 16px Arial';
            hybrid2Ctx.fillText('Hybrid 2: SCKM → DBSCAN', 20, 30);
            
            const stepDescriptions = [
                'Langkah 1/4: SCKM: Bentuk klaster kontigu (3 klaster)',
                'Langkah 2/4: DBSCAN: Terapkan dalam setiap klaster untuk deteksi sub-struktur',
                'Langkah 3/4: Hasil: Klaster kontigu dengan sub-klaster dan noise internal',
                'Langkah 4/4: Visualisasi akhir struktur hierarkis'
            ];
            
            if (hybrid2Step < stepDescriptions.length) {
                hybrid2Ctx.fillStyle = '#718096';
                hybrid2Ctx.font = '14px Arial';
                hybrid2Ctx.fillText(stepDescriptions[hybrid2Step], 20, 60);
            }
            
            // Draw statistics
            const internalNoiseCount = hybrid2Points.filter(p => p.isInternalNoise).length;
            const subclusterCount = new Set(hybrid2Points.filter(p => p.dbscanSubcluster >= 0).map(p => p.dbscanSubcluster)).size;
            
            hybrid2Ctx.fillStyle = '#1a2980';
            hybrid2Ctx.font = 'bold 14px Arial';
            hybrid2Ctx.fillText(`Sub-klaster: ${subclusterCount}, Noise internal: ${internalNoiseCount}`, 20, 380);
        }
        
        // Step forward in Hybrid 2 algorithm
        function nextStepHybrid2() {
            if (hybrid2Step < hybrid2MaxSteps) {
                hybrid2Step++;
                
                // Execute step logic
                if (hybrid2Step === 2) {
                    // Apply DBSCAN within each SCKM cluster
                    hybrid2Points.forEach(point => {
                        // Randomly assign subclusters and internal noise
                        if (Math.random() < 0.1) {
                            point.isInternalNoise = true;
                        } else {
                            point.dbscanSubcluster = Math.floor(Math.random() * 3);
                        }
                    });
                } else if (hybrid2Step === 3) {
                    // Refine subclusters
                    // Already done in step 2
                }
                
                drawHybrid2();
                updateHybrid2AlgorithmSteps();
            }
        }
        
        // Step backward in Hybrid 2 algorithm
        function prevStepHybrid2() {
            if (hybrid2Step > 0) {
                hybrid2Step--;
                
                // Reset points based on step
                if (hybrid2Step === 0) {
                    // Reset to initial SCKM clusters
                    const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
                    hybrid2Points.forEach(point => {
                        point.dbscanSubcluster = -1;
                        point.isInternalNoise = false;
                        point.color = clusterColors[point.sckmCluster];
                    });
                } else if (hybrid2Step === 1) {
                    // Keep SCKM clusters but remove DBSCAN results
                    const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166'];
                    hybrid2Points.forEach(point => {
                        point.dbscanSubcluster = -1;
                        point.isInternalNoise = false;
                        point.color = clusterColors[point.sckmCluster];
                    });
                }
                
                drawHybrid2();
                updateHybrid2AlgorithmSteps();
            }
        }
        
        // Update Hybrid 2 algorithm steps highlighting
        function updateHybrid2AlgorithmSteps() {
            // Reset all steps
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`hybrid2-step-${i}`);
                if (stepEl) stepEl.classList.remove('active');
            }
            
            // Highlight current step
            if (hybrid2Step >= 0 && hybrid2Step < 4) {
                const currentStepEl = document.getElementById(`hybrid2-step-${hybrid2Step + 1}`);
                if (currentStepEl) currentStepEl.classList.add('active');
            }
        }
        
        // =============================================
        // Simulation Visualization
        // =============================================
        const simDataCanvas = document.getElementById('sim-data-canvas');
        const simDataCtx = simDataCanvas.getContext('2d');
        let simDataPoints = [];
        let simTrueClusters = 4;
        let simulationStep = 0;
        let simulationMaxSteps = 3;
        
        // Simulation Result Canvases
        const simDBSCANCanvas = document.getElementById('sim-dbscan-canvas');
        const simDBSCANCtx = simDBSCANCanvas.getContext('2d');
        
        const simSTDBSCANCanvas = document.getElementById('sim-stdbscan-canvas');
        const simSTDBSCANCtx = simSTDBSCANCanvas.getContext('2d');
        
        const simSCKMCanvas = document.getElementById('sim-sckm-canvas');
        const simSCKMCtx = simSCKMCanvas.getContext('2d');
        
        const simSTSCKMCanvas = document.getElementById('sim-stsckm-canvas');
        const simSTSCKMCtx = simSTSCKMCanvas.getContext('2d');
        
        const simHybrid1Canvas = document.getElementById('sim-hybrid1-canvas');
        const simHybrid1Ctx = simHybrid1Canvas.getContext('2d');
        
        const simHybrid2Canvas = document.getElementById('sim-hybrid2-canvas');
        const simHybrid2Ctx = simHybrid2Canvas.getContext('2d');
        
        // Method colors
        const methodColors = [
            '#FF6B6B', '#4ECDC4', '#FFD166', '#9B5DE5', '#00BBF9', '#FF9E6D',
            '#1A2980', '#26d0ce', '#FF5252', '#4CAF50'
        ];
        
        // Initialize simulation data
        function initSimulation() {
            simDataPoints = [];
            simulationStep = 0;
            
            // Get simulation parameters
            const dataType = document.getElementById('sim-data-type-select').value;
            const numPoints = parseInt(document.getElementById('sim-points-slider').value);
            const noisePercent = parseInt(document.getElementById('sim-noise-slider').value);
            simTrueClusters = parseInt(document.getElementById('sim-true-clusters-slider').value);
            
            // Update display values
            document.getElementById('sim-points-value').textContent = numPoints;
            document.getElementById('sim-noise-value').textContent = `${noisePercent}%`;
            document.getElementById('sim-true-clusters-value').textContent = simTrueClusters;
            
            // Generate clusters based on data type
            const clusterColors = ['#FF6B6B', '#4ECDC4', '#FFD166', '#9B5DE5', '#00BBF9', '#FF9E6D'];
            
            // Calculate points per cluster
            const noisePoints = Math.floor(numPoints * noisePercent / 100);
            const clusterPoints = Math.floor((numPoints - noisePoints) / simTrueClusters);
            
            // Generate cluster points
            for (let c = 0; c < simTrueClusters; c++) {
                let clusterCenterX, clusterCenterY, clusterSpread;
                
                // Adjust cluster parameters based on data type
                switch(dataType) {
                    case 'well-clustered':
                        clusterCenterX = 100 + (c % 3) * 200;
                        clusterCenterY = 100 + Math.floor(c / 3) * 200;
                        clusterSpread = 40;
                        break;
                    case 'noisy':
                        clusterCenterX = 150 + (c % 3) * 200;
                        clusterCenterY = 150 + Math.floor(c / 3) * 200;
                        clusterSpread = 60;
                        break;
                    case 'overlap':
                        clusterCenterX = 200 + (c % 3) * 150;
                        clusterCenterY = 200 + Math.floor(c / 3) * 150;
                        clusterSpread = 80;
                        break;
                    case 'varying-density':
                        clusterCenterX = 100 + (c % 3) * 250;
                        clusterCenterY = 100 + Math.floor(c / 3) * 250;
                        clusterSpread = 30 + c * 20; // Varying density
                        break;
                    case 'temporal':
                        clusterCenterX = 150 + (c % 3) * 200;
                        clusterCenterY = 150 + Math.floor(c / 3) * 200;
                        clusterSpread = 50;
                        break;
                }
                
                for (let i = 0; i < clusterPoints; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * clusterSpread + 20;
                    
                    const x = clusterCenterX + Math.cos(angle) * distance;
                    const y = clusterCenterY + Math.sin(angle) * distance;
                    
                    // Ensure point is within canvas
                    const boundedX = Math.max(20, Math.min(simDataCanvas.width - 20, x));
                    const boundedY = Math.max(20, Math.min(simDataCanvas.height - 20, y));
                    
                    simDataPoints.push({
                        x: boundedX,
                        y: boundedY,
                        trueCluster: c,
                        isNoise: false,
                        color: clusterColors[c]
                    });
                }
            }
            
            // Generate noise points
            for (let i = 0; i < noisePoints; i++) {
                const x = Math.random() * (simDataCanvas.width - 40) + 20;
                const y = Math.random() * (simDataCanvas.height - 40) + 20;
                
                simDataPoints.push({
                    x: x,
                    y: y,
                    trueCluster: -1,
                    isNoise: true,
                    color: '#718096'
                });
            }
            
            // Shuffle points
            for (let i = simDataPoints.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [simDataPoints[i], simDataPoints[j]] = [simDataPoints[j], simDataPoints[i]];
            }
            
            drawSimData();
            drawMethodResults(); // Draw method results too
            
            // Update data statistics
            updateSimulationStats();
            
            // Clear simulation results
            document.getElementById('simulation-results').innerHTML = '<p style="color: var(--gray); text-align: center; padding: 20px;">Klik "Jalankan Semua Metode" untuk melihat hasil perbandingan</p>';
            document.getElementById('simulation-summary').innerHTML = '<tr><td colspan="7" style="text-align: center; color: var(--gray); padding: 20px;">Hasil simulasi akan muncul di sini setelah dijalankan</td></tr>';
        }
        
        // Draw simulation data
        function drawSimData() {
            simDataCtx.clearRect(0, 0, simDataCanvas.width, simDataCanvas.height);
            
            // Draw points
            simDataPoints.forEach(point => {
                simDataCtx.beginPath();
                simDataCtx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                simDataCtx.fillStyle = point.color;
                simDataCtx.fill();
            });
            
            // Draw title
            const dataType = document.getElementById('sim-data-type-select').value;
            const dataTypeNames = {
                'well-clustered': 'Berklaster Baik',
                'noisy': 'Banyak Noise',
                'overlap': 'Overlap Antar Klaster',
                'varying-density': 'Kepadatan Berbeda',
                'temporal': 'Pola Temporal'
            };
            
            simDataCtx.fillStyle = '#2d3748';
            simDataCtx.font = 'bold 16px Arial';
            simDataCtx.fillText(`Data Simulasi: ${dataTypeNames[dataType]}`, 20, 30);
            
            // Draw step description
            const stepDescriptions = [
                'Langkah 1/3: Data simulasi dengan ground truth',
                'Langkah 2/3: Aplikasi semua metode klastering',
                'Langkah 3/3: Hasil perbandingan dan evaluasi'
            ];
            
            if (simulationStep < stepDescriptions.length) {
                simDataCtx.fillStyle = '#718096';
                simDataCtx.font = '14px Arial';
                simDataCtx.fillText(stepDescriptions[simulationStep], 20, 60);
            }
            
            // Draw statistics
            const noiseCount = simDataPoints.filter(p => p.isNoise).length;
            const clusterCount = simDataPoints.filter(p => !p.isNoise).length;
            
            simDataCtx.fillStyle = '#718096';
            simDataCtx.font = '14px Arial';
            simDataCtx.fillText(`Total titik: ${simDataPoints.length}, Klaster: ${simTrueClusters}, Noise: ${noiseCount}`, 20, 380);
        }
        
        // Step forward in simulation
        function nextStepSimulation() {
            if (simulationStep < simulationMaxSteps) {
                simulationStep++;
                
                if (simulationStep === 1) {
                    // Step 1: Show data with ground truth
                    drawSimData();
                } else if (simulationStep === 2) {
                    // Step 2: Apply all methods
                    runAllMethods();
                } else if (simulationStep === 3) {
                    // Step 3: Show comparison results
                    drawSimData();
                    displaySimulationResults();
                }
            }
        }
        
        // Draw method results based on simulated clusters
        function drawMethodResults() {
            // Clear all canvases
            simDBSCANCtx.clearRect(0, 0, simDBSCANCanvas.width, simDBSCANCanvas.height);
            simSTDBSCANCtx.clearRect(0, 0, simSTDBSCANCanvas.width, simSTDBSCANCanvas.height);
            simSCKMCtx.clearRect(0, 0, simSCKMCanvas.width, simSCKMCanvas.height);
            simSTSCKMCtx.clearRect(0, 0, simSTSCKMCanvas.width, simSTSCKMCanvas.height);
            simHybrid1Ctx.clearRect(0, 0, simHybrid1Canvas.width, simHybrid1Canvas.height);
            simHybrid2Ctx.clearRect(0, 0, simHybrid2Canvas.width, simHybrid2Canvas.height);
            
            // Get data type for simulation behavior
            const dataType = document.getElementById('sim-data-type-select').value;
            
            // Generate clustering results for each method
            const results = generateClusteringResults(dataType);
            
            // Draw each method's results
            drawMethodResult(simDBSCANCtx, simDBSCANCanvas, results.dbscan, 'DBSCAN', dataType);
            drawMethodResult(simSTDBSCANCtx, simSTDBSCANCanvas, results.stDbscan, 'ST-DBSCAN', dataType);
            drawMethodResult(simSCKMCtx, simSCKMCanvas, results.sckm, 'SCKM', dataType);
            drawMethodResult(simSTSCKMCtx, simSTSCKMCanvas, results.stSckm, 'ST-SCKM', dataType);
            drawMethodResult(simHybrid1Ctx, simHybrid1Canvas, results.hybrid1, 'Hybrid 1', dataType);
            drawMethodResult(simHybrid2Ctx, simHybrid2Canvas, results.hybrid2, 'Hybrid 2', dataType);
            
            // Update cluster count displays
            updateClusterCounts(results);
        }
        
        // Generate clustering results for each method
        function generateClusteringResults(dataType) {
            const results = {
                dbscan: { clusters: [], noise: [], centroids: [] },
                stDbscan: { clusters: [], noise: [], centroids: [] },
                sckm: { clusters: [], noise: [], centroids: [] },
                stSckm: { clusters: [], noise: [], centroids: [] },
                hybrid1: { clusters: [], noise: [], centroids: [] },
                hybrid2: { clusters: [], noise: [], centroids: [], subclusters: [] }
            };
            
            // Base the results on the simulation data
            // For simplicity, we'll simulate different clustering behaviors
            
            // DBSCAN results
            results.dbscan.clusters = Array(3).fill().map(() => []);
            results.dbscan.noise = [];
            
            // ST-DBSCAN results (similar to DBSCAN but with temporal dimension)
            results.stDbscan.clusters = Array(4).fill().map(() => []);
            results.stDbscan.noise = [];
            
            // SCKM results (NO NOISE, fixed number of clusters)
            results.sckm.clusters = Array(3).fill().map(() => []);
            results.sckm.noise = []; // SCKM TIDAK MEMILIKI NOISE
            results.sckm.centroids = [
                { x: 150, y: 150 },
                { x: 350, y: 100 },
                { x: 550, y: 150 }
            ];
            
            // ST-SCKM results (NO NOISE, with temporal dimension)
            results.stSckm.clusters = Array(3).fill().map(() => []);
            results.stSckm.noise = []; // ST-SCKM TIDAK MEMILIKI NOISE
            results.stSckm.centroids = [
                { x: 150, y: 150, z: 1 },
                { x: 350, y: 100, z: 2 },
                { x: 550, y: 150, z: 3 }
            ];
            
            // Hybrid 1 results (DBSCAN then SCKM)
            results.hybrid1.clusters = Array(3).fill().map(() => []);
            results.hybrid1.noise = [];
            results.hybrid1.centroids = [
                { x: 150, y: 150 },
                { x: 350, y: 100 },
                { x: 550, y: 150 }
            ];
            
            // Hybrid 2 results (SCKM then DBSCAN)
            results.hybrid2.clusters = Array(3).fill().map(() => []);
            results.hybrid2.noise = [];
            results.hybrid2.subclusters = Array(6).fill().map(() => []);
            
            // Adjust results based on data type
            switch(dataType) {
                case 'well-clustered':
                    // All methods perform well
                    break;
                case 'noisy':
                    // Methods with noise detection perform better
                    results.dbscan.noise = Array(15).fill().map(() => ({}));
                    results.stDbscan.noise = Array(15).fill().map(() => ({}));
                    results.hybrid1.noise = Array(15).fill().map(() => ({}));
                    // SCKM and ST-SCKM tetap TANPA NOISE
                    results.sckm.noise = [];
                    results.stSckm.noise = [];
                    break;
                case 'overlap':
                    // ST methods handle overlap better
                    results.dbscan.clusters = Array(2).fill().map(() => []);
                    results.stDbscan.clusters = Array(3).fill().map(() => []);
                    results.stSckm.clusters = Array(3).fill().map(() => []);
                    break;
                case 'varying-density':
                    // DBSCAN struggles, hybrid methods better
                    results.dbscan.clusters = Array(4).fill().map(() => []);
                    results.dbscan.noise = Array(10).fill().map(() => ({}));
                    results.hybrid1.clusters = Array(4).fill().map(() => []);
                    results.hybrid2.subclusters = Array(8).fill().map(() => []);
                    break;
                case 'temporal':
                    // ST methods excel
                    results.stDbscan.clusters = Array(4).fill().map(() => []);
                    results.stSckm.clusters = Array(4).fill().map(() => []);
                    break;
            }
            
            return results;
        }
        
        // Draw a method's clustering result
        function drawMethodResult(ctx, canvas, result, methodName, dataType) {
            // Scale factor to fit simulation points to canvas
            const scaleX = canvas.width / simDataCanvas.width;
            const scaleY = canvas.height / simDataCanvas.height;
            
            // Draw points from simulation data with method's clustering
            simDataPoints.forEach((point, index) => {
                const x = point.x * scaleX;
                const y = point.y * scaleY;
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                
                // Determine color based on method and point
                let color = methodColors[index % methodColors.length];
                
                // Assign colors based on method characteristics
                if (methodName === 'DBSCAN') {
                    // DBSCAN: some points are noise
                    if (result.noise.length > 0 && index % 5 === 0) {
                        color = '#9B5DE5'; // Noise
                    } else {
                        color = methodColors[index % 3];
                    }
                } else if (methodName === 'ST-DBSCAN') {
                    // ST-DBSCAN: similar to DBSCAN but with temporal clusters
                    if (result.noise.length > 0 && index % 6 === 0) {
                        color = '#9B5DE5'; // Noise
                    } else {
                        color = methodColors[index % 4];
                    }
                } else if (methodName === 'SCKM') {
                    // SCKM: NO NOISE, all points in clusters
                    color = methodColors[index % 3];
                } else if (methodName === 'ST-SCKM') {
                    // ST-SCKM: NO NOISE, with temporal dimension
                    color = methodColors[index % 3];
                } else if (methodName === 'Hybrid 1') {
                    // Hybrid 1: DBSCAN noise then SCKM clusters
                    if (result.noise.length > 0 && index % 7 === 0) {
                        color = '#9B5DE5'; // Noise
                    } else {
                        color = methodColors[index % 3];
                    }
                } else if (methodName === 'Hybrid 2') {
                    // Hybrid 2: SCKM clusters then DBSCAN subclusters
                    color = methodColors[index % 3];
                    // Add subcluster indicator for some points
                    if (index % 4 === 0) {
                        ctx.strokeStyle = '#1A2980';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
                
                ctx.fillStyle = color;
                ctx.fill();
            });
            
            // Draw centroids for methods that have them
            if (result.centroids && result.centroids.length > 0) {
                result.centroids.forEach(centroid => {
                    const x = centroid.x * scaleX;
                    const y = centroid.y * scaleY;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#1A2980';
                    ctx.fill();
                    
                    // Draw cross inside centroid
                    ctx.beginPath();
                    ctx.moveTo(x - 4, y);
                    ctx.lineTo(x + 4, y);
                    ctx.moveTo(x, y - 4);
                    ctx.lineTo(x, y + 4);
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }
            
            // Draw method name
            ctx.fillStyle = '#2d3748';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(methodName, 10, 20);
            
            // Add note for temporal methods
            if (methodName === 'ST-DBSCAN' || methodName === 'ST-SCKM') {
                ctx.fillStyle = '#00BBF9';
                ctx.font = '12px Arial';
                ctx.fillText('+ waktu', 10, 35);
            }
            
            // Add note for noise detection
            if ((methodName === 'DBSCAN' || methodName === 'ST-DBSCAN' || methodName === 'Hybrid 1') && 
                dataType === 'noisy') {
                ctx.fillStyle = '#FF6B6B';
                ctx.font = '11px Arial';
                ctx.fillText('Deteksi noise', 10, canvas.height - 10);
            }
            
            // Add note for NO NOISE in SCKM and ST-SCKM
            if ((methodName === 'SCKM' || methodName === 'ST-SCKM')) {
                ctx.fillStyle = '#4ECDC4';
                ctx.font = '11px Arial';
                ctx.fillText('Tanpa noise', 10, canvas.height - 10);
            }
        }
        
        // Update cluster count displays
        function updateClusterCounts(results) {
            // DBSCAN
            const dbscanClusters = results.dbscan.clusters.length;
            const dbscanNoise = results.dbscan.noise.length;
            document.getElementById('dbscan-cluster-count').textContent = `Klaster: ${dbscanClusters} | Noise: ${dbscanNoise}`;
            
            // ST-DBSCAN
            const stdbscanClusters = results.stDbscan.clusters.length;
            const stdbscanNoise = results.stDbscan.noise.length;
            document.getElementById('stdbscan-cluster-count').textContent = `Klaster: ${stdbscanClusters} | Noise: ${stdbscanNoise}`;
            
            // SCKM - TIDAK ADA NOISE
            const sckmClusters = results.sckm.clusters.length;
            document.getElementById('sckm-cluster-count').textContent = `Klaster: ${sckmClusters} | Noise: 0`;
            
            // ST-SCKM - TIDAK ADA NOISE
            const stsckmClusters = results.stSckm.clusters.length;
            document.getElementById('stsckm-cluster-count').textContent = `Klaster: ${stsckmClusters} | Noise: 0`;
            
            // Hybrid 1
            const hybrid1Clusters = results.hybrid1.clusters.length;
            const hybrid1Noise = results.hybrid1.noise.length;
            document.getElementById('hybrid1-cluster-count').textContent = `Klaster: ${hybrid1Clusters} | Noise: ${hybrid1Noise}`;
            
            // Hybrid 2
            const hybrid2Clusters = results.hybrid2.clusters.length;
            const hybrid2Subclusters = results.hybrid2.subclusters.length;
            const hybrid2Noise = results.hybrid2.noise.length;
            document.getElementById('hybrid2-cluster-count').textContent = `Klaster: ${hybrid2Clusters} | Sub-klaster: ${hybrid2Subclusters} | Noise: ${hybrid2Noise}`;
        }
        
        // Update simulation statistics
        function updateSimulationStats() {
            const noiseCount = simDataPoints.filter(p => p.isNoise).length;
            const totalPoints = simDataPoints.length;
            const noisePercent = Math.round(noiseCount / totalPoints * 100);
            
            // Calculate overlap (simplified)
            let overlap = 'Rendah';
            const dataType = document.getElementById('sim-data-type-select').value;
            if (dataType === 'overlap') overlap = 'Tinggi';
            else if (dataType === 'varying-density') overlap = 'Sedang';
            
            // Update statistics display
            document.getElementById('stat-points').textContent = totalPoints;
            document.getElementById('stat-clusters').textContent = simTrueClusters;
            document.getElementById('stat-noise').textContent = `${noisePercent}%`;
            document.getElementById('stat-overlap').textContent = overlap;
        }
        
        // Run all methods on simulation data
        function runAllMethods() {
            const resultsContainer = document.getElementById('simulation-results');
            const summaryTable = document.getElementById('simulation-summary');
            
            // Clear previous results
            resultsContainer.innerHTML = '<p style="color: var(--gray); text-align: center; padding: 20px;">Menjalankan semua metode...</p>';
            summaryTable.innerHTML = '';
            
            // Simulate running all methods
            setTimeout(() => {
                simulationStep = 2;
                displaySimulationResults();
                drawMethodResults(); // Draw method results after running
            }, 2000);
        }
        
        // Display simulation results
        function displaySimulationResults() {
            const resultsContainer = document.getElementById('simulation-results');
            const summaryTable = document.getElementById('simulation-summary');
            
            // Generate random results for each method
            const methods = [
                { name: 'DBSCAN', color: '#FF6B6B', icon: 'fas fa-dot-circle' },
                { name: 'ST-DBSCAN', color: '#4ECDC4', icon: 'fas fa-clock' },
                { name: 'SCKM', color: '#FFD166', icon: 'fas fa-map-marked-alt' },
                { name: 'ST-SCKM', color: '#9B5DE5', icon: 'fas fa-layer-group' },
                { name: 'Hybrid 1', color: '#00BBF9', icon: 'fas fa-random' },
                { name: 'Hybrid 2', color: '#1A2980', icon: 'fas fa-exchange-alt' }
            ];
            
            // Clear results
            resultsContainer.innerHTML = '';
            summaryTable.innerHTML = '';
            
            // Generate results for each method
            let bestSilhouette = { method: '', value: -1 };
            let bestDB = { method: '', value: Infinity };
            let bestARI = { method: '', value: -1 };
            let bestTime = { method: '', value: Infinity };
            
            methods.forEach((method, index) => {
                // Generate random metrics (real implementation would compute these)
                const silhouette = 0.3 + Math.random() * 0.5; // 0.3 to 0.8
                const dbIndex = 0.5 + Math.random() * 2; // 0.5 to 2.5
                const ari = 0.4 + Math.random() * 0.5; // 0.4 to 0.9
                const time = 0.1 + Math.random() * 2; // 0.1 to 2.1 seconds
                const noiseDetected = method.name === 'SCKM' || method.name === 'ST-SCKM' ? 0 : Math.floor(Math.random() * 100); // 0% for SCKM and ST-SCKM
                const contiguity = method.name === 'SCKM' || method.name === 'ST-SCKM' || method.name === 'Hybrid 1' || method.name === 'Hybrid 2' ? 'Tinggi' : 'Rendah';
                
                // Update best metrics
                if (silhouette > bestSilhouette.value) {
                    bestSilhouette = { method: method.name, value: silhouette };
                }
                if (dbIndex < bestDB.value) {
                    bestDB = { method: method.name, value: dbIndex };
                }
                if (ari > bestARI.value) {
                    bestARI = { method: method.name, value: ari };
                }
                if (time < bestTime.value) {
                    bestTime = { method: method.name, value: time };
                }
                
                // Add to summary table
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="font-weight: 600; color: ${method.color};">${method.name}</td>
                    <td>${silhouette.toFixed(3)}</td>
                    <td>${dbIndex.toFixed(3)}</td>
                    <td>${ari.toFixed(3)}</td>
                    <td>${time.toFixed(3)}</td>
                    <td>${noiseDetected}%</td>
                    <td>${contiguity}</td>
                `;
                summaryTable.appendChild(row);
                
                // Create result card
                const resultCard = document.createElement('div');
                resultCard.className = 'result-card';
                resultCard.innerHTML = `
                    <h4 class="result-title" style="color: ${method.color};">
                        <i class="${method.icon}"></i> ${method.name}
                    </h4>
                    <div class="result-metrics">
                        <div class="metric">
                            <span class="metric-name">Silhouette</span>
                            <span class="metric-value">${silhouette.toFixed(3)}</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">DB Index</span>
                            <span class="metric-value">${dbIndex.toFixed(3)}</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">ARI</span>
                            <span class="metric-value">${ari.toFixed(3)}</span>
                        </div>
                        <div class="metric">
                            <span class="metric-name">Waktu</span>
                            <span class="metric-value">${time.toFixed(3)}s</span>
                        </div>
                    </div>
                `;
                resultsContainer.appendChild(resultCard);
            });
            
            // Update best metrics display
            document.getElementById('best-silhouette').textContent = `${bestSilhouette.method} (${bestSilhouette.value.toFixed(3)})`;
            document.getElementById('best-db').textContent = `${bestDB.method} (${bestDB.value.toFixed(3)})`;
            document.getElementById('best-ari').textContent = `${bestARI.method} (${bestARI.value.toFixed(3)})`;
            document.getElementById('best-time').textContent = `${bestTime.method} (${bestTime.value.toFixed(3)}s)`;
            
            // Generate recommendation based on data type
            const dataType = document.getElementById('sim-data-type-select').value;
            let recommendation = '';
            
            switch(dataType) {
                case 'well-clustered':
                    recommendation = 'SCKM atau ST-SCKM (klaster terdefinisi dengan baik, tanpa noise)';
                    break;
                case 'noisy':
                    recommendation = 'Hybrid 1 (mendeteksi noise lalu klaster kontigu)';
                    break;
                case 'overlap':
                    recommendation = 'ST-DBSCAN atau ST-SCKM (mempertimbangkan dimensi waktu)';
                    break;
                case 'varying-density':
                    recommendation = 'Hybrid 2 (klaster kontigu dengan deteksi sub-struktur)';
                    break;
                case 'temporal':
                    recommendation = 'ST-DBSCAN atau ST-SCKM (pola temporal)';
                    break;
            }
            
            document.getElementById('method-recommendation').textContent = recommendation;
            
            // Update simulation step
            simulationStep = 3;
        }
        
        // =============================================
        // Event Listeners and Initialization
        // =============================================
        
        // Initialize all visualizations when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initDBSCAN();
            initSTDBSCAN();
            initSCKM();
            initSTSCKM();
            initHybrid1();
            initHybrid2();
            initSimulation();
        });
        
        // Event listeners for DBSCAN
        document.getElementById('reset-dbscan').addEventListener('click', initDBSCAN);
        document.getElementById('run-dbscan').addEventListener('click', () => {
            // Run full DBSCAN algorithm
            dbscanStep = 0;
            for (let i = 0; i <= dbscanMaxSteps; i++) {
                setTimeout(() => {
                    nextStepDBSCAN();
                }, i * 1000);
            }
        });
        document.getElementById('step-dbscan').addEventListener('click', nextStepDBSCAN);
        document.getElementById('prev-dbscan').addEventListener('click', prevStepDBSCAN);
        
        // DBSCAN parameter sliders
        document.getElementById('dbscan-eps-slider').addEventListener('input', function() {
            document.getElementById('dbscan-eps-value').textContent = this.value;
            initDBSCAN();
        });
        
        document.getElementById('dbscan-minpts-slider').addEventListener('input', function() {
            document.getElementById('dbscan-minpts-value').textContent = this.value;
            initDBSCAN();
        });
        
        document.getElementById('dbscan-points-slider').addEventListener('input', function() {
            document.getElementById('dbscan-points-value').textContent = this.value;
            initDBSCAN();
        });
        
        // Event listeners for ST-DBSCAN
        document.getElementById('reset-st-dbscan').addEventListener('click', initSTDBSCAN);
        document.getElementById('run-st-dbscan').addEventListener('click', () => {
            // Run full ST-DBSCAN algorithm
            stDBSCANStep = 0;
            for (let i = 0; i <= stDBSCANMaxSteps; i++) {
                setTimeout(() => {
                    nextStepSTDBSCAN();
                }, i * 1000);
            }
        });
        document.getElementById('step-st-dbscan').addEventListener('click', nextStepSTDBSCAN);
        document.getElementById('prev-st-dbscan').addEventListener('click', prevStepSTDBSCAN);
        
        // ST-DBSCAN parameter sliders
        document.getElementById('st-dbscan-eps-s-slider').addEventListener('input', function() {
            document.getElementById('st-dbscan-eps-s-value').textContent = this.value;
            initSTDBSCAN();
        });
        
        document.getElementById('st-dbscan-eps-t-slider').addEventListener('input', function() {
            document.getElementById('st-dbscan-eps-t-value').textContent = this.value;
            initSTDBSCAN();
        });
        
        document.getElementById('st-dbscan-minpts-slider').addEventListener('input', function() {
            document.getElementById('st-dbscan-minpts-value').textContent = this.value;
            initSTDBSCAN();
        });
        
        document.getElementById('st-dbscan-time-slider').addEventListener('input', function() {
            document.getElementById('st-dbscan-time-value').textContent = this.value;
            initSTDBSCAN();
        });
        
        // Event listeners for SCKM
        document.getElementById('reset-sckm').addEventListener('click', initSCKM);
        document.getElementById('run-sckm').addEventListener('click', () => {
            // Run full SCKM algorithm
            sckmStep = 0;
            for (let i = 0; i <= sckmMaxSteps; i++) {
                setTimeout(() => {
                    nextStepSCKM();
                }, i * 1000);
            }
        });
        document.getElementById('step-sckm').addEventListener('click', nextStepSCKM);
        document.getElementById('prev-sckm').addEventListener('click', prevStepSCKM);
        
        // SCKM parameter sliders
        document.getElementById('sckm-lambda-slider').addEventListener('input', function() {
            document.getElementById('sckm-lambda-value').textContent = this.value;
            initSCKM();
        });
        
        document.getElementById('sckm-k-slider').addEventListener('input', function() {
            document.getElementById('sckm-k-value').textContent = this.value;
            initSCKM();
        });
        
        document.getElementById('sckm-epsilon-slider').addEventListener('input', function() {
            document.getElementById('sckm-epsilon-value').textContent = this.value;
            initSCKM();
        });
        
        // Event listeners for ST-SCKM
        document.getElementById('reset-st-sckm').addEventListener('click', initSTSCKM);
        document.getElementById('run-st-sckm').addEventListener('click', () => {
            // Run full ST-SCKM algorithm
            stSCKMStep = 0;
            for (let i = 0; i <= stSCKMMaxSteps; i++) {
                setTimeout(() => {
                    nextStepSTSCKM();
                }, i * 1000);
            }
        });
        document.getElementById('step-st-sckm').addEventListener('click', nextStepSTSCKM);
        document.getElementById('prev-st-sckm').addEventListener('click', prevStepSTSCKM);
        
        // ST-SCKM parameter sliders
        document.getElementById('st-sckm-ws-slider').addEventListener('input', function() {
            document.getElementById('st-sckm-ws-value').textContent = this.value;
            // Update wt to maintain ws + wt = 1
            const wt = 1 - parseFloat(this.value);
            document.getElementById('st-sckm-wt-slider').value = wt;
            document.getElementById('st-sckm-wt-value').textContent = wt.toFixed(1);
            initSTSCKM();
        });
        
        document.getElementById('st-sckm-wt-slider').addEventListener('input', function() {
            document.getElementById('st-sckm-wt-value').textContent = this.value;
            // Update ws to maintain ws + wt = 1
            const ws = 1 - parseFloat(this.value);
            document.getElementById('st-sckm-ws-slider').value = ws;
            document.getElementById('st-sckm-ws-value').textContent = ws.toFixed(1);
            initSTSCKM();
        });
        
        document.getElementById('st-sckm-lambda-slider').addEventListener('input', function() {
            document.getElementById('st-sckm-lambda-value').textContent = this.value;
            initSTSCKM();
        });
        
        document.getElementById('st-sckm-time-slider').addEventListener('input', function() {
            document.getElementById('st-sckm-time-value').textContent = this.value;
            initSTSCKM();
        });
        
        // Event listeners for Hybrid 1
        document.getElementById('reset-hybrid1').addEventListener('click', initHybrid1);
        document.getElementById('run-hybrid1').addEventListener('click', () => {
            // Run full Hybrid 1 algorithm
            hybrid1Step = 0;
            for (let i = 0; i <= hybrid1MaxSteps; i++) {
                setTimeout(() => {
                    nextStepHybrid1();
                }, i * 1000);
            }
        });
        document.getElementById('step-hybrid1').addEventListener('click', nextStepHybrid1);
        document.getElementById('prev-hybrid1').addEventListener('click', prevStepHybrid1);
        
        // Hybrid 1 parameter sliders
        document.getElementById('hybrid1-dbscan-eps-slider').addEventListener('input', function() {
            document.getElementById('hybrid1-dbscan-eps-value').textContent = this.value;
            initHybrid1();
        });
        
        document.getElementById('hybrid1-dbscan-minpts-slider').addEventListener('input', function() {
            document.getElementById('hybrid1-dbscan-minpts-value').textContent = this.value;
            initHybrid1();
        });
        
        document.getElementById('hybrid1-sckm-lambda-slider').addEventListener('input', function() {
            document.getElementById('hybrid1-sckm-lambda-value').textContent = this.value;
            initHybrid1();
        });
        
        document.getElementById('hybrid1-sckm-k-slider').addEventListener('input', function() {
            document.getElementById('hybrid1-sckm-k-value').textContent = this.value;
            initHybrid1();
        });
        
        // Event listeners for Hybrid 2
        document.getElementById('reset-hybrid2').addEventListener('click', initHybrid2);
        document.getElementById('run-hybrid2').addEventListener('click', () => {
            // Run full Hybrid 2 algorithm
            hybrid2Step = 0;
            for (let i = 0; i <= hybrid2MaxSteps; i++) {
                setTimeout(() => {
                    nextStepHybrid2();
                }, i * 1000);
            }
        });
        document.getElementById('step-hybrid2').addEventListener('click', nextStepHybrid2);
        document.getElementById('prev-hybrid2').addEventListener('click', prevStepHybrid2);
        
        // Hybrid 2 parameter sliders
        document.getElementById('hybrid2-sckm-lambda-slider').addEventListener('input', function() {
            document.getElementById('hybrid2-sckm-lambda-value').textContent = this.value;
            initHybrid2();
        });
        
        document.getElementById('hybrid2-sckm-k-slider').addEventListener('input', function() {
            document.getElementById('hybrid2-sckm-k-value').textContent = this.value;
            initHybrid2();
        });
        
        document.getElementById('hybrid2-dbscan-eps-slider').addEventListener('input', function() {
            document.getElementById('hybrid2-dbscan-eps-value').textContent = this.value;
            initHybrid2();
        });
        
        document.getElementById('hybrid2-dbscan-minpts-slider').addEventListener('input', function() {
            document.getElementById('hybrid2-dbscan-minpts-value').textContent = this.value;
            initHybrid2();
        });
        
        // Event listeners for Simulation
        document.getElementById('regenerate-sim').addEventListener('click', initSimulation);
        document.getElementById('run-all-methods').addEventListener('click', () => {
            simulationStep = 0;
            for (let i = 0; i <= simulationMaxSteps; i++) {
                setTimeout(() => {
                    nextStepSimulation();
                }, i * 1000);
            }
        });
        document.getElementById('step-simulation').addEventListener('click', nextStepSimulation);
        
        // Simulation parameter controls
        document.getElementById('sim-data-type-select').addEventListener('change', initSimulation);
        document.getElementById('sim-points-slider').addEventListener('input', function() {
            document.getElementById('sim-points-value').textContent = this.value;
            initSimulation();
        });
        
        document.getElementById('sim-noise-slider').addEventListener('input', function() {
            document.getElementById('sim-noise-value').textContent = `${this.value}%`;
            initSimulation();
        });
        
        document.getElementById('sim-true-clusters-slider').addEventListener('input', function() {
            document.getElementById('sim-true-clusters-value').textContent = this.value;
            initSimulation();
        });
        
        // Save image functionality
        function saveImage(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            // Show notification
            showSaveNotification();
        }
        
        // Show save notification
        function showSaveNotification() {
            const notification = document.createElement('div');
            notification.className = 'save-notification';
            notification.innerHTML = `
                <i class="fas fa-check-circle"></i>
                <span>Gambar berhasil disimpan!</span>
            `;
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Attach save functionality to all save buttons
        document.getElementById('save-dbscan').addEventListener('click', () => saveImage('dbscan-canvas', 'dbscan-visualization.png'));
        document.getElementById('save-st-dbscan').addEventListener('click', () => saveImage('st-dbscan-canvas', 'st-dbscan-visualization.png'));
        document.getElementById('save-sckm').addEventListener('click', () => saveImage('sckm-canvas', 'sckm-visualization.png'));
        document.getElementById('save-st-sckm').addEventListener('click', () => saveImage('st-sckm-canvas', 'st-sckm-visualization.png'));
        document.getElementById('save-hybrid1').addEventListener('click', () => saveImage('hybrid1-canvas', 'hybrid1-visualization.png'));
        document.getElementById('save-hybrid2').addEventListener('click', () => saveImage('hybrid2-canvas', 'hybrid2-visualization.png'));
        document.getElementById('save-sim-data').addEventListener('click', () => saveImage('sim-data-canvas', 'simulation-data.png'));
        
        // Add save functionality for method result images
        document.querySelectorAll('.save-method-img').forEach(button => {
            button.addEventListener('click', function() {
                const canvasId = this.getAttribute('data-canvas');
                const filename = this.getAttribute('data-filename');
                saveImage(canvasId, filename);
            });
        });
        
        // Add floating animation to badges
        const badges = document.querySelectorAll('.badge');
        badges.forEach((badge, index) => {
            badge.style.animation = `float 3s ease-in-out ${index * 0.5}s infinite`;
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            // Redraw canvases on resize
            setTimeout(() => {
                drawDBSCAN();
                drawSTDBSCAN();
                drawSCKM();
                drawSTSCKM();
                drawHybrid1();
                drawHybrid2();
                drawSimData();
                drawMethodResults();
            }, 100);
        });
    </script>
</body>
</html>
